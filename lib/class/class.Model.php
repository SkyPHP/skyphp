<?php

/**
 *  Data modeling and CRUD handler
 *  see: http://switchbreak.com/skyphp/classes/model
 */
class Model implements ArrayAccess {

    /**
     *  static storage of aql statements and arrays, linked to aql2array storage
     *  @var array
     */
    public static $_metadata = array();

    /**
     *  @var string
     */
    const E_READ_ONLY = 'The site is currently in "read only" mode. Changes have not been saved. Try again later.';

    /**
     *  @var string
     */
    const E_NO_METHOD_EXISTS = 'Cannot call a method that does not exist.';

    /**
     *  @var string
     */
    const E_METHOD_NOT_CALLABLE = 'This method is not callable.';

    /**
     *  @var string
     */
    const E_INVALID_MODEL = 'AQL Error: <strong>%s</strong> is not a valid model.';

    /**
     *  @var string
     */
    const E_PROPERTY_DOES_NOT_EXIST = 'Property [%s] does not exist in this model.';

    /**
     *  @var string
     */
    const E_METHOD_ALREADY_DEFINED = 'Method [%s] is already defined in this model.';

    /**
     *  @var string
     */
    const E_FIELD_IS_REQUIRED = '%s is required.';

    /**
     *  @var string
     */
    const E_FIELD_IS_INVALID = '%s is invalid.';

    /**
     *  @var string
     */
    const E_NO_VALIDATION_CLASS = 'Cannot use this validation features without the Validation class.';

    /**
     *  if true, the save will return after_save() without saving.
     *  @var Boolean
     */
    public $_abort_save = false;

    /**
     *  store actual .aql file when found or input aql
     *  @var string
     */
    public $_aql = null;

    /**
     *  generated by $this->_aql
     *  this is only set if $this->_aql is set
     *  @var array
     */
    public $_aql_array = array();

    /**
     *  associative array of array('model_name' => 'constructor_field')
     *  see Mode::refreshBelongsTo()
     *  @var array
     */
    public $_belongs_to = array();

    /**
     *  used to compare with static::$mod_time to see if the model is outdated
     *  @var string
     */
    public $_cached_time = null;

    /**
     *  stored data, corresponds to $this->_properties
     *  @var array
     */
    public $_data = array();

    /**
     *  array of errors, if it is non empty save()/delete() will return after_fail()
     *  @var array
     */
    public $_errors = array();

    /**
     *  If true, loadDB() will always bypass cache
     *  @var Boolean
     */
    public $_force_db = false;

    /**
     *  Identifier set during loadDB() and reload()
     *  @var int
     */
    public $_id;

    /**
     *  settings used to ignore these fields on save
     *  keys of arrays: tables (for joins), models (plural/singular by alias), subs
     *  @var array
     */
    public $_ignore = array();

    /**
     *  names of objects
     *  @var array
     */
    public $_objects = array();

    /**
     *  method storage used in addMethod()
     *  @var array
     */
    public $_methods = array();

    /**
     *  set by class name (if is a subclass)
     *  @var string
     */
    public $_model_name = null;

    /**
     *  primary table of the model
     *  @var string
     */
    public $_primary_table = null;

    /**
     *  array of properties allowed to be set, generated by the model's aql statement
     *  @var array
     */
    public $_properties = array();

    /**
     *  associative array of required fields array('field' => 'Display Name')
     *  @var array
     */
    public $_required_fields = array();

    /**
     *  key value pairs added to/ merged with this array
     *  will be returned in response arrays (merged)
     *  @var array
     */
    public $_return = array();

    /**
     *  used to authorize updates
     *  @var string
     */
    public $_token = null;

    ## these are configuration properties
    ## that can be set in the model __construct method $config param

    /**
     *  if true, there will be no caching because this model has no name
     *  @var Boolean
     */
    protected $_aql_set_in_constructor = false;

    /**
     *  If false, $model->_token is not required for save/delete
     *  @var Boolean
     */
    protected $_use_token_validation = true;

    /**
     *  If false, sub objects caches will not be automatically refetched
     *  @var Boolean
     */
    protected $_refresh_sub_models = true;

    /**
     *  used for saving sub models (not requiring token validation for inner saves)
     *  @var Boolean
     */
    protected $_is_inner_save = false;

    /**
     *  Model constructor accepts arguments in a variety of ways:
     *
     *  $o = new artist($data);
     *  $o = new artist($id);
     *  $o = new artist($id, $conf);             maps to new artist($id, null, false, $conf);
     *  $o = new artist($id, true);              maps to new artist($id, null, true);
     *  $o = new artist($id, true, $conf);       maps to new artist($id, null, true, $conf);
     *  $o = new Model($id, $artist_aql, $conf); maps to new Model($id, $artist_aql, false, $conf);
     *
     *  @param mixed $data      identifier
     *                          id, ide triggers loadDB()
     *                          array/object triggers loadArray()
     *  @param mixed $aql       set aql for this model (if this is not a subclass)
     *  @param mixed $force_db  if true we're loading from DB and writing to cache
     *  @param array $config    configuration options
     *
     */
    final public function __construct($data = null, $aql = null, $force_db = false, $cnf = array()) {

        # map arguments to correct vars
        list($aql, $force_db, $cnf) = $this->mapConstructArgs($aql, $force_db, $cnf);

        # initialize this model
        $this->_model_name = get_class($this);
        $this->_getModelAql($aql)->makeProperties();

        # set if we're refreshing it
        $this->_force_db = ($force_db || $_GET['refresh']);

        # set configuration options for
        $this->setConfig($cnf);

        # load from DB if $id is set proper, otherwise throw Exception
        $this->checkConstructorData($data, $force_db);

        # run construct hook
        $this->construct();
    }


    /**
     *  checks for a proper identifier, loads object if set
     *  @param  mixed   $data               ID/IDE/stdClass/array
     *  @param  Boolean $force_db           force db read (only valid if $data is id/ide)
     *  @throws InvalidArgumentException    if invalid constructor type
     */
    final protected function checkConstructorData($data = null, $force_db = false) {

        if (!$data) return;

        # handle if we're loading
        if (is_string($data) || is_numeric($data)) {
            $this->loadDB($data, $force_db);
            $this->_token = $this->getToken();
            return;
        }

        # if stdClass cast it to array
        $data = (is_object($data) && get_class($data) == 'stdClass')
            ? (array) $data
            : $data;

        # load array if it's an associative array
        if (is_assoc($data)) {
            $this->loadArray($data);
            return;
        }

        # if we got this far there is a problem
        $e = 'The model __construct method does not support %s as a first argument. '
           . 'Only: null|false|numeric|IDE|array|stdClass';
        throw new InvalidArgumentException(sprintf($e, gettype($id)));

    }


    /**
     *  maps constructor arguments to a standard format by type
     *  @param  mixed $aql
     *  @param  mixed $force_db
     *  @param  mixed $cnf
     *  @return array
     */
    final protected function mapConstructArgs($aql = null, $force_db = false, $cnf = array()) {

        if (is_array($force_db)) {
            $cnf = $force_db;
            $force_db = false;
        }

        if (is_array($aql)) {
            $cnf = $aql;
            $aql = null;
        } else if (is_bool($aql)) {
            $force_db = $aql;
            $aql = null;
        }

        # return fixed and uniform arguments
        return array($aql, $force_db, $cnf);
    }

    /**
     *  so as to not use $this->methodExists() in constructor
     *  @return Model $this
     */
    public function construct() { return $this; }

    /**
     *  magic __call method
     *  @param  string  $method
     *  @param  array   $params
     *  @return mixed
     *  @throws Exception   if invalid method
     */
    public function __call($method, $params) {

        if (!$this->methodExists($method)) {
            throw new Exception(self::E_NO_METHOD_EXISTS);
        }

        if (!is_callable($this->_methods[$method])) {
            throw new Exception(self::E_METHOD_NOT_CALLABLE);
        }

        return call_user_func_array($this->_methods[$method], $params);
    }

    /**
     *  if this model is called as a function, return dataToArray();
     *      ex: $o = new artist;
     *          $o(); # equivalent to $o->dataToArray();
     *  @return array
     */
    public function __invoke() {
        return $this->dataToArray();
    }


    /**
     *  Maps uses _getField as a magic getter if property exists
     *  @param string $name
     *  @return mixed
     */
    final public function __get($name) {
        return ($this->propertyExists($name))
            ? $this->_getField($name)
            : null;
    }

    /**
     *  @param string $name
     *  @return mixed
     */
    protected function _getField($name) {
        return $this->_data[$name];
    }

    /**
     *  Magic Setter -- sets values to $this->_data
     *  If $name looks like an ide, the ID version is set
     *  Adds to errors if setting an invalid property
     *
     *  @param string $name
     *  @param mixed $value
     *  @return Model $this
     */
    public function __set($name, $value) {

        # check to see if this is a valid property or IDE
        $is_ide = preg_match('/_ide$/', $name);
        if (!$this->propertyExists($name) && !$is_ide) {
            $this->_errors[] = sprintf(self::E_PROPERTY_DOES_NOT_EXIST, $name);
            return $this;
        }

        # if this is an IDE we add it as a property to the object
        if (!$this->propertyExists($name)) $this->addProperty($name);

        # cast to array or to ModelArrayObject as necessary
        $value = $this->prepSetValue($value);

        $this->_data[$name] = $value;

        #if is IDE, add as an ID as well
        if ($is_ide) {
            $key = aql::get_decrypt_key($name); # decrypt ide
            $n_name = substr($name, 0, -1);     # remove e (from ide)
            $this->_data[$n_name] = decrypt($value, $key);
        }

        return $this;
    }

    /**
     *  cast value to array if it is a stdClass
     *  to arrayobject if it is an array otherwise return it as it was
     *  @param  mixed $val
     *  @return mixed
     */
    private function prepSetValue($val) {
        if (!is_array($val) && !is_object($val)) return $val;
        if (is_array($val)) return self::toArrayObject($val);
        if (get_class($val) == 'stdClass') return (array) $val;
        return $val;
    }

    /**
     *  casting a Model to a string returns $this->getID()
     *  @return string
     */
    public function __toString() {
        return (string) $this->getID();
    }

    /**
     *  This will trigger aborting of $this->save();
     *  Validation still happens, and response is returned (after_fail or after_save)
     *  @return Model $this
     */
    public function abortSave() {
        $this->_abort_save = true;
        return $this;
    }


    /**
     *  merge to the required fields array
     *  @param  array $arr                  associative array
     *  @return Model $this
     *  @throws InvalidArgumentException    $arr not associative
     */
    public function addRequiredFields($arr = array()) {

        $e = 'Model::addRequiredFields expects an associative array '
           . 'with field => return name as a structure.';
        if (!is_assoc($arr)) throw new InvalidArgumentException($e);

        $this->_required_fields = array_merge($this->_required_fields, $arr);
        return $this;
    }

    /**
     *  add any number of properties to the object
     *  @param string   (any number of arguments)
     *  @return Model $this
    */
    public function addProperty() {
        $num_args = func_num_args();
        $args = func_get_args();
        for ($i = 0; $i < $num_args; $i++) {
            $this->_properties[$args[$i]] = true;
        }
        return $this;
    }


    /**
     *  alias for Model::addProperty()
     *  @return Model $this
     */
    public function addProperties() {
        $args = func_get_args();
        call_user_func_array(array($this, 'addProperty'), $args);
        return $this;
    }

    /**
     *  add a method to this model
     *      usage:
     *          $model->addMethod('testing', function($arg) use($model) {
     *              // body
     *          });
     *          $model->testing($somearg);
     *  @param  string      $name
     *  @param  callback    $fn
     *  @return Model       $this
     *  @throws Exception   method is already defined
     */
    public function addMethod($name, $fn) {

        if ($this->methodExists($name)) {
            throw new Exception(sprintf(self::E_METHOD_ALREADY_DEFINED, $name));
        }

        $this->_methods[$name] = $fn;
        return $this;
    }

    /**
     *  @param  string $name
     *  @return Boolean
     */
    public function methodExists($name) {
        return (method_exists($this, $name))
            ?: array_key_exists($name, $this->_methods);
    }

    /**
     *  plural subobject specific "array_map", because these are not arrays
     *  if the model has [sub_model]s
     *  $model->mapSubObjects('sub_model', $callback)
     *
     *  @param  string $name                object name
     *  @param  callback $fn                defaults to null
     *  @param  Boolean $skip_id_filter     skip is filter, defaults to false
     *  @return array                       like in array map
     *
     *  @throws Exception                   invalid $name
     */
    public function mapSubObjects($name, $fn = null, $skip_id_filter = false) {

        if (!$this->isPluralObject($name)) {
            throw new Exception('mapSubObjects expects a valid plural object param.');
        }

        $re = array();
        foreach ($this->$name as $o) {
            if (!$skip_id_filter && !$o->getID()) continue;
            $re[] = ($fn) ? $fn($o) : $o;
        }
        return $re;
    }

    /**
     *  @param  array $arr  the save array
     *  @return array       response array
     */
    public function after_fail($arr = array()) {
        return array_merge(array(
            'status' => 'Error',
            'errors' => $this->_errors,
            'data' => $this->dataToArray(true)
        ), $this->_return);
    }

    /**
     *  @param  array $arr  the save array
     *  @return array       response array
     */
    public function after_save($arr = array()) {
        return array_merge(array(
            'status' => 'OK',
            'data' => $this->dataToArray(true),
            '_token' => $this->getToken()
        ), $this->_return);
    }

    /**
     *  @return Boolean
     */
    public function hasRequiredFields() {
        return (bool) (count($this->getRequiredFields() > 0));
    }

    /**
     *  @return array
     */
    public function getRequiredFields() {
        return array_keys($this->_required_fields);
    }

    /**
     *  @return int | null
     */
    public function getID() {
        $field = $this->getPrimaryTable() . '_id';
        $field_ide = $field . 'e' ;
        return $this->{$field} = ($this->{$field})
            ?: (($this->{$field_ide})
                ? decrypt($this->{$field_ide}, $this->_primary_table)
                : null);
    }

    /**
     *  @return string | null
     */
    public function getIDE() {
        $field = $this->getPrimaryTable() . '_id';
        $field_ide = $field . 'e';
        return ($this->{$field_ide})
            ?: (($this->{$field})
                ? encrypt($this->{$field}, $this->_primary_table)
                : null);
    }

    /**
     *  @return Boolean
     */
    public function hasID() {
        return (bool) $this->getID();
    }

    /**
     *  Uses required fields to fetch the identifier of the object if it is not set
     *  Should generally be used in postValidate() for a uniqueness constraint on the
     *  required fields
     *  This sets $this->{primary_table_id}
     *
     *  @return Model   $this
     */
    public function getIDByRequiredFields() {

        # if there are errors | have ID | no required fields return
        if ($this->_errors || $this->getID() || !$this->hasRequiredFields()) {
            return $this;
        }

        # set up
        $where = array();
        $clause = array('limit' => 1, 'where' => &$where);
        $aql = sprintf('%s { }', $this->getPrimaryTable());
        $key = $this->getPrimaryTable() . '_id';

        # make where
        foreach ($this->getRequiredFields() as $f) {
            $where[] = sprintf("%s = '%s'", $f, $this->{$f});
        }

        $rs = aql::select($aql, $clause);
        $this->{$key} = ($rs[0][$key]) ?: $this->{$key};
        $this->_token = ($this->_token) ?: $this->getToken();

        return $this;
    }

    /**
     *  Use to repopulate required fields from the database on save.
     *  Only sets them if they are empty.
     *  Must be called within a model. Best to use in preValidate(),
     *  if the object must be unique.
     *
     *  @param  int     $id     defaults to $this->getID(), exits if not present
     *  @return Model   $this
     */
    public function preFetchRequiredFields($id = null) {
        $id = ($id) ?: $this->getID();
        if (!$id) return $this;

        $keys = $this->getRequiredFields();

        $continue = false;
        foreach ($keys as $f) {
            if (!$this->fieldIsSet($f)) {
                $continue = true;
                break;
            }
        }

        # return if all required fields are already set
        if (!$continue) return $this;

        # get data
        $r = aql::profile($this->getStoredAqlArray(), $id);
        if ($r) foreach ($keys as $f) {
            if (!$this->fieldIsSet($f)) $this->_data[$f] = $r[$f];
        }

        return $this;
    }

    /**
     *  returns $this->_data in array form
     *  we use ModelArrayObjects instead of arrays and these need to get converted back
     *
     *  @param  Boolean     $hide_ids   if true, remove "_id" fields (keep _ides)
     *                                  default false
     *  @return array
     */
    public function dataToArray($hide_ids = false) {
        $return = array();
        $arr = ($arr) ?: $this->_data;
        foreach ($arr as $k => $v) {
            if ($this->_objects[$k] === 'plural') {
                foreach ($v as $i => $o) {
                    if (self::isModelClass($o)) {
                        $return[$k][$i] = $o->dataToArray($hide_ids);
                    }
                }
            } else if ($this->_objects[$k] && get_class($v) != 'ModelArrayObject') {
                $return[$k] = $v->dataToArray($hide_ids);
            } else if (is_object($v) && get_class($v) == 'ModelArrayObject') {
                $return[$k] = self::dataToArraySubQuery($v);
            } else {
                $is_id = (substr($k, -3) == '_id');
                if (!$is_id || !$hide_ids) {
                    $return[$k] = $v;
                }
            }
        }
        return $return;
    }

    /**
     *  Helper for Model::dataToArray() for when this is a ModelArrayObject
     *  @param  array   $arr
     *  @param  Boolean $hide_ids
     *  @return array
     */
    public function dataToArraySubQuery($arr = array(), $hide_ids = false) {
        $return = array();
        foreach ($arr as $k => $v) {
            if (is_object($v) && self::isModelClass($v)) {
                $return[$k] = $v->dataToArray($hide_ids);
            } elseif (is_object($v) && get_class($v) == 'ModelArrayObject') {
                $return[$k] = self::dataToArraySubQuery($v, $hide_ids);
            } else {
                if (is_object($v)) $v = (array) $v;
                $is_id = (substr($k, -3) == '_id');
                if (!$is_id || !$hide_ids) {
                    $return[$k] = $v;
                }
            }
        }
        unset($arr);
        return $return;
    }


    /**
     *  Deletes the current record if there is a token and identifier
     *  by setting active = 0
     *  and clears memcache
     *
     *  Triggers events: before_delete and after_delete
     *  Refreshes $this->_belongs_to
     *
     *  @return array   the response array (after_fail or after_save)
     *  @global $model_dependencies
     */
    public function delete() {

        $id = $this->getID();

        if ($this->_token != Model::generateToken($id, $this->_primary_table) || !$this->_token) {
            $this->_errors[] = 'You do not have permission to remove this record.';
        }

        if (!$id) {
            $this->_errors[] = 'Identifier is not set, there is nothing to delete.';
        }

        if ($this->_errors) {
            return $this->after_fail();
        }

        $now = aql::now();

        $fields = array(
            'active' => 0,
            'mod_time' => $now,
            'update_time' => $now
        );

        if (defined('PERSON_ID') && PERSON_ID) {
            $fields['mod__person_id'] = $fields['update__person_id'] = PERSON_ID;
        }

        # load the object
        # so that we have the information left over for after_delete hooks
        $this->loadDB($id);

        if ($this->methodExists('before_delete')) {
            $this->before_delete();
        }

        if (aql::update($this->_primary_table, $fields, $id)) {

            # clears the memcache of stored objects of this identifier.
            $delete_key = function($m) use($id) {
                $key = sprintf('%s:loadDB:%d', $m, $id);
                mem($key, null);
            };

            if ($this->_model_name != 'Model') {
                global $model_dependencies;
                $delete_key($this->_model_name);
                if (is_array($model_dependencies[$this->_primary_table])) {
                    foreach ($model_dependencies[$this->_primary_table] as $m) {
                        $delete_key($m);
                    }
                }
            }

            if ($this->methodExists('after_delete')) {
                $this->after_delete();
            }

            $this->refreshBelongsTo();

            return array('status' => 'OK');

        } else {
            $this->_errors[] = 'Error Deleting.';
            return $this->after_fail();
        }

    }

    /**
     *  @param  string $ext         extension for file, default: php
     *  @return string              path to form file with given extension
     *  @global $sky_aql_model_path
     */
    public function getFormPath($ext = 'php') {
        global $sky_aql_model_path;
        $format = '%s%s/form.%s.%s';
        $with = array($sky_aql_model_path, $this->_model_name, $this->_model_name, $ext);
        return vsprintf($format, $with);
    }

    /**
     *  Includes the form file (path/to/models/Model/form.Model.php) in $this scope
     *  @return Model
     *  @throws Exception       path not found
     */
    public function includeForm() {
        $path = $this->getFormPath();
        if (!file_exists_incpath($path)) {
            throw new Exception("Form file [{$path}] does not exist for this model");
        }
        $r = $o = $this;
        include $path;
        return $this;
    }

    /**
     *  Triggers DBW transaction failure
     *  @global $dbw
     */
    public function failTransaction() {
        global $dbw;
        $dbw->FailTrans();
    }

    /**
     *  runs generic validation on the field given using Validation class in CMS.
     *
     *  @param  string $field       name of the field
     *  @param  string $name        display name of the field, used for errors
     *  @param  string $val         value of the field
     *  @param  string $fn          name of the method to use in validation class
     *  @param  boolean $replace    if true, replace the value given with return of
     *                              ValidationMethod
     *
     *  @throws Exception           Validation class doesnt exist
     */
    public function genericValidation($field, $name, $val, $fn, $replace = false) {

        if (!class_exists('validation')) {
            throw new Exception(self::E_NO_VALIDATION_CLASS);
        }

        # exit if we can't call this function
        if (!$field || !$name || !is_callable('validation', $fn) || !$val) return;

        $valid = validation::$fn($val);

        if (!$valid) {
            $this->_errors[] = sprintf(self::E_FIELD_IS_INVALID, $name);
        } else if ($replace) {
            $this->_data[$field] = $valid;
        }

    }

    /**
     *  @param  string $str             model name
     *  @param  mixed $id               identifier (id, ide)
     *  @param  Boolean $force_db       force_db read, defaults to false
     *  @return Model
     *
     *  @throws Exception               no model name
     */
    public static function get($str = null, $id = null, $force_db = false) {

        if (!is_string($str)) {
            throw new Exception('Model name or AQL must be specified when using Model::get()');
        }

        # get class if it exists
        aql::include_class_by_name($str);
        return (class_exists($str))
            ? new $str($id, null, $force_db)
            : new Model($id, $str);

    }


    /**
     *  Does not check the cache for the object,
     *  reads directly from DB and writes to cache.
     *  @param  mixed $id   identifier (id, ide)
     *  @return Model
     *  @throws Exception   if called on Model (not subclass)
     */
    public static function refreshCache($id) {
        $class = get_called_class();

        if ($class == 'Model') {
            throw new Exception('Model::refreshCache needs to be called on a subclass');
        }

        return new $class($id, null, true);
    }

    /**
     *  example:
     *      if the model is:
     *          artist {
     *              ... fields
     *              [artist_album]s,
     *              [artist_genre]s,
     *              [artist_label]
     *          }
     *      php:
     *      $o = artist::getPartial($id, array(
     *          'artist_label' => true,
     *          'artist_album' => array(
     *              'artist_album_label' => true
     *          )
     *      ));
     *  @param  mixed $id       identifier (id, ide)
     *  @param  array $refresh  associative array of values to refresh
     *                          (multidimentional possibly)
     *  @return Model
     */
    public static function getPartial($id = null, $refresh = array()) {

        $cl = get_called_class();

        $o = new $cl($id, null, false, array(
            'refresh_sub_models' => false
        ));

        if (is_array($refresh)) foreach ($refresh as $k => $v) {
            if (!$o->isObjectParam($k)) continue;
            if ($o->isPluralObject($k)) {
                foreach ($o->{$k} as $key => $sub) {
                    $class = get_class($sub);
                    $o->$k[$key] = $class::getPartial($sub->getID(), $v);
                }
            } else {
                $class = get_class($o->$k);
                $o->$k = $class::getPartial($o->$k->getID(), $v);
            }
        }

        return $o;

    }

    /**
     *  get the name of hte object if it has an alias
     *  @param  string  $str    object alias
     *  @return mixed           string or null (if not found)
     */
    public function getActualObjectName($str) {
        if (!$this->isObjectParam($str)) return null;
        foreach ($this->getStoredAqlArray() as $table) {
            if ($table['objects'][$str]) {
                return $table['objects'][$str]['model'];
            }
        }
        return null;
    }

    /**
     *  @return string      AQL statement of calling class
     */
    public static function getAQL() {
        $c = get_called_class();
        return self::_getAql($c);
    }

    /**
     *  sets model name based on aql, sets this as a tmp model (_aql_set_in_constructor)
     *  @param string $aql      aql statemnt or empty
     *  @return Model
     */
    public function _getModelAql($aql = null) {
        if ($this->getStoredAql()) return $this;
        if (!$aql) { $this->_getAql($this->_model_name); }
        else if (aql::is_aql($aql)) { $this->_aql = $aql; $this->_aql_set_in_constructor = true; }
        else { $this->_model_name = $aql; $this->_getAql($this->_model_name); }
        return $this;
    }

    /**
     *  @return string      get model aql statement
     */
    public function getStoredAql() {
        return (aql2array::$aqls[$this->_model_name]) ?: $this->_aql;
    }

    /**
     *  @return array       get model aqlarray (parsed aql)
     */
    public function getStoredAqlArray() {
        return (aql2array::$aqlArrays[$this->_model_name]) ?: $this->_aql_array;
    }

    /**
     *  @param string $model_name       name of model
     *  @return string                  aql statemnt
     */
    public function _getAql($model_name) {
        return if_not(aql2array::$aqls[$model_name], function() use($model_name) {
            return aql2array::$aqls[$model_name] = aql::get_aql($model_name);
        });
    }

    /**
     *  returns an array of objects or one object if limit is set to 1
     *  @param array $clause        clause array
     *  @param string $model_name   model name, if null, using called class
     *  @return mixed   if limit => 1, object or null, otherwise an array (can be empty)
     */
    public static function getByClause($clause, $model_name = null) {
        $model_name = ($model_name) ?: self::getCalledClass();
        if (!$model_name || $model_name == 'Model') {
            throw new Exception('Model::getByClause expects a second parameter of model_name.');
        }
        if (!$clause['where']) {
            throw new Exception('Model::getByClause expects a where clause.');
        }
        $rs = aql::select(aql::get_min_aql_from_model($model_name), $clause);
        foreach ($rs as $k => $v) {
            $rs[$k] = new $model_name($v['id']);
        }
        return ($clause['limit'] === 1) ? $rs[0] : $rs;
    }

    /**
     *  return array of objects matching the criteria specified
     *  @param array $clause
     *  @return array of Model objects
     */
    public static function getMany() {
        return call_user_func_array(array(get_called_class(),'getByClause'), func_get_args());
    }

    /**
     *  return a single object matching the criteria specified
     *  @param array $clause
     *  @return Model
     */
    public static function getOne() {
        return call_user_func_array(array(get_called_class(),'getByClause'), func_get_args());
    }

    /**
     *  return the count of objects matching the criteria specified
     *  @param array $clause
     *  @return int
     */
    public static function count($clause_array=array()) {
        return static::getList($clause_array, true);
    }

    /**
     *  returns an array of ids
     *  @param array $clause            clause array
     *  @param Boolean $do_count        if true, returns a count of the list
     *  @return array
     */
    public static function getList($clause = array(), $do_count = false) {
        $model_name = self::getCalledClass();
        if (!$model_name || $model_name == 'Model') {
            throw new Exception("Model::getList expects a clause array as a parameter.");
        }
        $sql = aql::sql(aql::get_aql($model_name), $clause);
        if ($do_count) {
            $r = sql($sql['sql_count']);
            return $r->Fields('count');
        } else {
            $ids = array();
            $r = sql($sql['sql_list']);
            while (!$r->EOF) {
                $ids[] = $r->Fields('id');
                $r->moveNext();
            }
            return $ids;
        }

    }

    /**
     *  to be used on an instantiated object
     *  @param mixed $id                identifier(id, ide), default: $this->getID()
     *  @param string $primary_table    primary_table, default: $this->getPrimaryTable()
     *  @return mixed                   string or null
     */
    public function getToken($id = null, $primary_table = null) {
        $primary_table = ($primary_table) ?: $this->getPrimaryTable();
        if ($id && !is_numeric($id)) $id = decrypt($id, $primary_table);
        $id = ($id) ?: $this->getID();
        return self::_makeToken($id, $primary_table);
    }

    /**
     *  to be used statically
     *  @param mixed $id                identifier (id, ide)
     *  @param string $primary_table    primary_table, default to get called class
     *  @return mixed                   string or null
     */
    public static function generateToken($id = null, $primary_table = null) {

        if (!$primary_table) {
            $cl = get_called_class();
            $o = new $cl;
            return $o->getToken($id);
        }

        if ($id && !is_numeric($id)) $id = decrypt($id, $primary_table);
        return self::_makeToken($id, $primary_table);
    }

    /**
     *  @param int $id
     *  @param string $table
     *  @return mixed       string or null
     */
    private static function _makeToken($id, $table) {
        if (!$id || !$table) return null;
        return encrypt($id, encrypt($id, $table));
    }

    /**
     *  @return mixed       string or null (class name)
     */
    public function getCalledClass() {
        if (!self::isStaticCall()) return get_class($this);
        return (function_exists('get_called_class'))
            ? get_called_class()
            : null;
    }

    /**
     *  @return array
     */
    public function getAqlArray() {
        return $this->getStoredAqlArray();
    }

    /**
     *  returns model name or stored aql depending on if it is a temp model or not
     *  @return string
     */
    public function getModel() {
        return $this->getStoredAql();
    }

    /**
     *  returns model name or aql array depending on if its a temp model
     *  @return mixed       array or string
     */
    public function getModelName() {
        return (get_class($this) == 'Model')
            ? $this->getStoredAqlArray()
            : $this->_model_name;
    }

    /**
     *  @return string
     */
    public function getPrimaryTable() {
        return $this->_primary_table;
    }

    /**
     *  @return array
     */
    public function getProperties() {
        return array_keys($this->_properties);
    }

    /**
     *  @param Object $class
     *  @return Boolean
     */
    public static function isModelClass($class) {
        return (is_a($class, 'Model'));
    }

    /**
     *  @param  string $str      property name
     *  @return Boolean
     */
    public function isObjectParam($str) {
        return array_key_exists($str, $this->_objects);
    }

    /**
     *  @param string $str      property name
     *  @return Boolean
     */
    public function isPluralObject($str) {
        return ($this->isObjectParam($str))
            ? ($this->_objects[$str] === 'plural')
            : false;
    }

    /**
     *  @param string $str      property name
     *  @return Boolean
     */
    public function isSingleObject($str) {
        return ($this->isObjectParam($str) && !$this->isPluralObject($str));
    }

    /**
     *  Properly loads an associative array of properties into the object
     *  decrypting ides if necessary
     *  creating objects if necessary
     *
     *  @param array $array
     *  @return Model       $this
     */
    public function loadArray($array = array()) {
        if (!$array) $array = $_POST;
        if (is_array($array)) foreach ($array as $k => $v) {
            if ($k == '_token') {
                $this->{$k} = $v;
            } else if ($this->propertyExists($k) || preg_match('/(_|\b)id(e)*?$/', $k)) {
                if ($this->isObjectParam($k)) {
                    $obj = $this->getActualObjectName($k);
                    aql::include_class_by_name($obj);
                    if ($this->_objects[$k] === 'plural') {
                        foreach ($v as $key => $arr) {
                            if (is_array($arr)) {
                                $this->_data[$k][$key] = (class_exists($obj))
                                    ? new $obj()
                                    : new Model(null, $obj);
                                $this->_data[$k][$key]->loadArray($arr);
                            } else {
                                $this->_data[$k][$key] = $arr;
                            }
                        }
                        $this->_data[$k] = new ModelArrayObject($this->_data[$k]);
                    } else {
                        if (is_array($v)) {
                            $this->_data[$k] = (class_exists($obj))
                                ? new $obj()
                                : new Model(null, $obj);
                            $this->_data[$k]->loadArray($v);
                        } else {
                            $this->_data[$k] = $v;
                        }
                    }
                } else if (is_array($v)) {
                    $this->_data[$k] = $this->toArrayObject($v);
                } else {
                    if (substr($k, -4) == '_ide') {
                        $d = aql::get_decrypt_key($k);
                        $decrypted = decrypt($v, $d);
                        $field = substr($k, 0, -1);
                        $this->_data[$field] = $decrypted;
                        $this->_properties[$field] = true;
                    }
                    $this->_data[$k] = $v;
                    if (!$this->propertyExists($k)) $this->_properties[$k] = true;
                }
            }
        }
        return $this;
    }

    /**
     *  @param Model $o
     *  @return Boolean
     */
    public static function cacheExpired($o) {

        $mod_time = (isset($o::$mod_time))
            ? $o::$mod_time
            : null;

        if (!$mod_time) return false;
        if (!$o->_cached_time) return true;

        $is_expired = (bool) (strtotime($o->_cached_time) <= strtotime($mod_time));
        elapsed('cacheExpired:' . var_export($is_expired, true));
        return $is_expired;

    }

    /**
     *  @param mixed $id    identifier(id, ide), default: $this->getID()
     *  @return string
     */
    public function getMemKey($id = null) {

        $id = ($id) ?: $this->getID();
        if (!$id) return null;

        $v = (isset($this::$mod_time))
            ? ':v' . strtotime($this::$mod_time)
            : null;

        return $this->_model_name . ':loadDB' . $v . ':' . $id;

    }

    /**
     *  checks to see if this is a valid identifier for this Model
     *  Uses memcache first, then check DB
     *  @param  string | int    $id     id or ide of the model
     *  @return Boolean
     */
    public static function exists($id) {

        # memoize results to minimize requests to cache or db
        static $results = array();

        $cl = get_called_class();
        $o = new $cl;

        # make sure this is numeric or decryptable
        $table = $o->getPrimaryTable();
        $id = ($id && !is_numeric($id)) ? decrypt($id, $table) : $id;
        if (!$id || !$table) return false;

        $getSQL = function($table, $id) {
            $sql = 'SELECT id FROM %s WHERE id = %s AND active = 1';
            return sprintf($sql, $table, $id);
        };

        $key = $o->getMemKey($id);
        if (array_key_exists($key, $results)) {
            return $results[$key];
        }

        $found = (bool) mem($key);

        if (!$found) {
            # if we do not find it in memcache, check for the record in DB
            $sql = $getSQL($table, $id);
            $r = sql($sql);
            $found = (bool) ($r->Fields('id') == $id);
        }
        return $results[$key] = $found;
    }

    /**
     *  Attempts to fetch data from cache, sets the object,
     *  otherwise, reads from db, sets the object and cache
     *
     *  @param  mixed $id                   identifier(id, ide)
     *  @param  Boolean $force_db           force db read, default: false
     *  @param  Boolean $use_dbw            force master db read, default: false
     *  @return Model   $this
     *  @throws InvalidArgumentException    invalid identifier
     *  @throws ModelNotFoundException      when object not found
     *  @throws LogicException              if cannot generate cache key
     */
    public function loadDB($id, $force_db = false, $use_dbw = false) {

        $id = (!is_numeric($id)) ? decrypt($id, $this->getPrimaryTable()) : $id;

        if (!$id) {
            throw new InvalidArgumentException('Invalid Identifier passed to loadDB()');
        }

        $mem_key = $this->getMemKey($id);
        if (!$mem_key) {
            throw new LogicException('Could not generate cache key.');
        }

        # exit early if load will fail
        if ($this->_errors) return $this;

        # set booleans
        $reload_subs = false;
        $force_db = ($force_db || $this->_force_db || $_GET['refresh']) ? true : false;
        $is_subclass = ($this->_model_name != 'Model');

        # if reloading from DB, make sure we're doing it form Master, not slave.
        if ($force_db || $use_dbw) { $use_dbw = true; global $dbw; }
        $db_conn = ($use_dbw) ? $dbw : null;

        # for lexical binding with anonymous funcitons.
        $that = $this;

        # function that reads and sets data
        $load = function($mem_key = null) use($that, $db_conn, $id) {
            $o = aql::profile($that->getModelName(), $id, true, $that->_aql, true, $db_conn);
            if ($mem_key)  {    $o->_cached_time = date('c'); mem($mem_key, $o);    }
            return $o;
        };

        if (!$force_db && $is_subclass) {
            $o = mem($mem_key);         # do a normal get from cache
            if (!$o->_data || self::cacheExpired($o)) {
                $o = $load($mem_key);   # if cache not found or expired, load from DB
            } else {
                $reload_subs = true;    # we will be reloading submodels
            }
        } else if ($force_db && $is_subclass && !$this->_aql_set_in_constructor) {
            $o = $load($mem_key);       # refresh was specified
        } else {
            $o = $load();               # this is a temp model, fetch from db
        }

        if (self::isModelClass($o) && is_array($o->_data)) {

            # we have a proper object fetched, update the data in $this using $o
            $arr = array('data', 'properties', 'objects');

            array_walk($arr, function($key) use($o, $that) {
                $k = '_' . $key;
                $that->$k = array_merge($that->$k, $o->$k);
            });

            $this->_id = $id;
            $this->_cached_time = $o->_cached_time;

            if ($reload_subs) $this->reloadSubs($use_dbw);

        } else {
            # throw new ModelNotFoundException; # some time in the future
            $this->_errors[] = 'No data found for this identifier.';
        }

        return $this;

    }

    /**
     *  Used during save to pass created ids down to subobjects if the property exists
     *  @param array $ids       associative of id_field => value
     *  @return Model           $this
     */
    public function loadIDs($ids = array()) {
        foreach ($ids as $k => $v) {
            if (!$this->_data[$k] && $this->propertyExists($k)) $this->_data[$k] = $v;
        }
        return $this;
    }

    /**
     *  @param string $json
     *  @return Model $this
     */
    public function loadJSON($json) {
        $array = json_decode($json, true);
        if (is_array($array)) return $this->loadArray($array);
        $this->_errors[] = 'ERROR Loading JSON. JSON was not valid.';
        return $this;
    }


    /**
     *  Creates and stores the parsed AQL array
     */
    public function makeAqlArray() {
        if ($this->_model_name == 'Model' || !$this->_model_name) {
            $this->_aql_array = aql2array($this->_aql);
            return;
        } else {
            self::$_metadata[$this->_model_name]['aql_array'] = &aql2array::get($this->_model_name, $this->getStoredAql());
        }
    }

    /**
     *  makes a foreign key array from the aql array
     *  used to figure out in what order saves will happen if there are joins
     *  @param array $aql_array
     *  @return array
     */
    public function makeFKArray($aql_array) {
        $fk = array();
        foreach ($aql_array as $k => $v) {
            if (is_array($v['fk'])) foreach ($v['fk'] as $f) {
                $fk[$f][] = $v['table'] ;
            }
        }
        return $fk;
    }

    /**
     *  Recursively construct an array with key (table name), value (fields, id)
     *  to use in aql::insert() and aql::update()
     *  sets __objects__ key for subobjects
     *  sets subs for nested aql
     *
     *  @param array $data_array        defaults to $this->_data
     *  @param array $aql_array         defaults to $this->getStoredAqlArray()
     *  @return array
     */
    public function makeSaveArray($data_array = array(), $aql_array = array()) {

        # the set up (this method is recursive)
        if (!$data_array && !$aql_array) {
            $data_array = $this->_data;
            $aql_array = $this->getStoredAqlArray();
        }

        # initialize helpers
        $tmp = array();
        $addSubObject = function($o) use(&$tmp) {
            $tmp['__objects__'][] = array(
                'object' => get_class($o),
                'data' => $o->_data
            );
        };
        $is_IDE = function($field) {
            return (substr($field, '-4') == '_ide');
        };
        $is_ID = function($field) {
            return (substr($field, '-3') == '_id');
        };
        $isID = function($field) {
            return ($field == 'id');
        };
        $ideMatchesTable = function($ide, $table) {
            return (substr($k, 0, -4) == $table);
        };
        $prepName = function($str) {
            return substr($str, strpos($str, '.') + 1); # removes the table_name. prefix
        };

        if (is_array($data_array)) {

            foreach ($data_array as $k => $d) {

                if (!is_object($d) && !$this->isObjectParam($k)) {

                    # this aql level, tables/fields
                    foreach ($aql_array as $table => $info) {
                        $tname = $info['table'];
                        if ($info['fields'][$k]) {
                            $field_name = $prepName($info['fields'][$k]);
                            if ($isID($tmp[$tname]['fields'][$field_name])) {
                                $tmp[$tname]['id'] = $d;
                            } else {
                                $tmp[$tname]['fields'][$field_name] = $d;
                            }
                        } else if ($is_IDE($k)) {
                            if ($ideMatchesTable($k, $tname)) {
                                $tmp[$tname]['id'] = decrypt($d, $tname);
                            }
                        } else if ($is_ID($k)) {
                            $table_name = explode('__', substr($k, 0, -3));
                            $table_name = ($table_name[1]) ?: $table_name[0];
                            if ($tname == $table_name && $d !== NULL) {
                                $tmp[$tname]['id'] = $d;
                            }
                        }
                    }

                } else if ($this->isObjectParam($k)) {

                    # sub objects of this model
                    if ($this->isPluralObject($k)) {
                        foreach ($d as $i => $obj) {
                            $addSubObject($obj);
                        }
                    } else {
                        $addSubObject($d);
                    }

                } else {

                    # this is a "subquery"
                    foreach ($aql_array as $table => $info) {

                        if (!is_array($info['subqueries'])) continue;

                        $tname = $info['table'];
                        foreach ($info['subqueries'] as $sub_k => $sub_v) {
                            if ($k != $sub_k) continue;
                            foreach ($d as $i => $s) {
                                $s = (is_object($s) && get_class($s) == 'stdClass')
                                    ? (array) $s
                                    : $s;
                                $tmp[$tname]['subs'][] = $this->makeSaveArray($s, $sub_v);
                            }
                            break;
                        }

                    }
                } # end if subquery

            } # end for each data

        } # end if array

        # make sure that the array is in the correct order
        return self::makeSaveArrayOrder($tmp, self::makeFKArray($aql_array));
    }

    /**
     *  reorders the saveArray based on the foreign keys
     *  @param  array $save_array        saveArray
     *  @param  array $fk                foreign key array
     *  @return array
     */
    public function makeSaveArrayOrder($save_array, $fk) {
        $return_array = array();    # array to return
        $first = array();           # prepends to return array
        foreach ($fk as $parent => $subs) {
            foreach ($subs as $dependent) {
                if ($save_array[$dependent]) {
                    if (!array_key_exists($dependent, $fk)) {
                        $return_array[$dependent] = $save_array[$dependent];
                        unset($save_array[$dependent]);
                    } else {
                        $return_array = array($dependent => $save_array[$dependent]) + $return_array;
                        unset($save_array[$dependent]);
                    }
                }
            }
        }
        return $save_array + $return_array;
    }

    /**
     *  removes $this->_ignore props from the save array
     *  @param  array $save_array    save array
     *  @return array               filtered save array
     */
    public function removeIgnores($save_array = array()) {

        if (!$this->_ignore) {
            return $save_array;
        }

        # remove tables
        if (is_array($this->_ignore['tables'])) {
            foreach ($this->_ignore['tables'] as $remove) {
                if (!array_key_exists($remove, $save_array)) continue;
                unset($save_array[$remove]);
            }
        }

        # remove objects
        if (is_array($this->_ignore['objects']) && $save_array['__objects__']) {
            foreach ($this->_ignore['objects'] as $remove) {
                foreach ($save_array['__objects__'] as $k => $v) {
                    if ($v['object'] == $remove) {
                        unset($save_array['__objects__'][$k]);
                    }
                }
            }
        }

        # remove subs
        if (is_array($this->_ignore['subs'])) {
            foreach ($this->_ignore['subs'] as $remove) {
                foreach ($save_array as $i => $k) {
                    if (is_array($k['subs'])) foreach ($k['subs'] as $n => $sub) {
                        if (array_key_exists($remove, $sub)) {
                            unset($save_array[$i]['subs'][$n]);
                        } # endif exists
                    } # end subs
                } # end tables
            } # end removes
        }

        # remove fields
        if (is_array($this->_ignore['fields'])) {
            foreach ($this->_ignore['fields'] as $remove) {
                foreach($save_array as $k => $v) {
                    if (!is_array($v['fields'])) continue;
                    if (!array_key_exists($remove, $v['fields'])) continue;
                    unset($save_array[$k]['fields'][$remove]);
                }
            }
        }
        return $save_array;
    }

    /**
     *  @return Model       $this
     *  @throws Exception
     */
    public function makeProperties() {
        if ($this->getStoredAql()) {
            $this->makeAqlArray();
            $i = 0;
            foreach ($this->getStoredAqlArray() as $table) {
                if ($i == 0) {
                    $this->_primary_table = $table['table'];
                    $this->addProperty($this->_primary_table.'_id');
                }
                $this->tableMakeProperties($table);
                $i++;
            }
            unset($i);
        } else {
            $e = sprintf(self::E_INVALID_MODEL, $this->_model_name);
            if (!is_ajax_request()) {
                throw new Exception($e);
                return $this;
            } else {
                exit_json(array(
                    'status' => 'Error',
                    'errors' => array(
                       $e
                    )
                ));
            }
        }
        return $this;
    }

    /**
     *  @param string $offset
     */
    public function offsetExists($offset) {
        return isset($this->_data[$offset]);
    }

    /**
     *  @param string $offset
     */
    public function offsetGet($offset) {
        return (isset($this->_data[$offset])) ? $this->_data[$offset] : null;
    }

    /**
     *  @param string $offset
     *  @param value $value
     */
    public function offsetSet($offset, $value) {
        if (is_array($value)) $value = self::toArrayObject($value);
        $this->$offset = $value;
    }

    /**
     *  @param string $offset
     */
    public function offsetUnset($offset) {
        unset($this->_data[$offset]);
    }

    /**
     *  @param array $save_array    gets passed in after save
     *  @global $model_dependencies
     */
    public function reload($save_array = null) {
        global $model_dependencies;

        $t = $this->getPrimaryTable();
        $id = $save_array[$t]['id'] ?: $this->_id;
        $this->_id = ($id) ?: $this->getID();

        if ($this->_id) {
            $this->loadDB($this->_id, true, true);
            if ($t) {
                if (is_array($model_dependencies[$t])) {
                    foreach ($model_dependencies[$t] as $m) {
                        if ($m == $this->_model_name) continue;
                        Model::get($m, $this->_id, true);
                    }
                }
            }
        }

        $this->construct();

    }

    /**
     *  for when using memcache, if there are subobjects, re-fetch them from cache
     *  to make sure they are up to date
     *  @param  Boolean $use_dbw     use master DB
     *  @return Model   $this
     */
    public function reloadSubs($use_dbw = false) {

        if (!$this->_refresh_sub_models) {
            return $this;
        }

        $o = $this;
        $load = function($m) use($o, $use_dbw) {
            if (!Model::isModelClass($m) || !$m->_id) return;
            $m->_force_db = false;
            $m->loadDB($m->_id, $o->_force_db, $use_dbw);
            $m->construct();
        };
        $isPlural = function($type) {
            return ($type === 'plural');
        };

        foreach ($this->_objects as $o => $type) {
            if ($isPlural($type)) {
                foreach ($this->_data[$o] as $obj) {
                    $load($obj);
                }
            } else {
                $load($obj);
            }
        }

        return $this;
    }

    /**
     *  disables refresh_sub_models
     */
    public function disableSubReload() {
        $this->_refresh_sub_models = false;
    }

    /**
     *  @param string   as many as needed, unsets the keys from _properties
     *  @return Model   $this
     */
    public function removeProperty() {
        $num_args = func_num_args();
        $args = func_get_args();
        for ($i = 0; $i < $num_args; $i++) {
            unset($this->_properties[$args[$i]]);
        }
        return $this;
    }

    /**
     *  @param  array $arr                  associative array of values to save
     *  @return array                       response array
     *  @throws InvalidArgumentException    if non associative array given
     *  @throws BadMethodCallException      if model has no identifier
     */
    public function saveProperties($arr = array()) {

        if (!$this->hasID()) {
            throw new BadMethodCallException('No identifier in model');
        }

        if (!$arr || !is_assoc($arr)) {
            throw new InvalidArgumentException('Expects a non empty associatve array.');
        }

        $class = get_called_class();
        $t_ide = $this->getPrimaryTable() . '_ide';
        $arr = array_merge($arr, array(
            $t_ide => $this->getIDE(),
            '_token' => $this->getToken()
        ));

        $tmp = new $class($arr);
        $re = $tmp->save();

        if ($re['status'] == 'OK') {
            foreach (array_keys($arr) as $k) {
                $this->$k = $tmp->$k;
            }
        }

        return $re;
    }

    /**
     *  has hooks that take the save array as an argument
     *      - before_insert, after_insert
     *      - before_update, after_update
     *
     *  @param Boolean $inner   if this is an inner save
     *  @return array           response array
     *  @global $dbw
     *  @global $db_platform
     *  @global $aql_error_email
     *  @global $is_dev
     */
    public function save($inner = false) {

        global $dbw, $db_platform, $aql_error_email, $is_dev;

        if (!$dbw) $this->_errors[] = self::E_READ_ONLY;

        if ($inner) {
            $this->_use_token_validation = false;
            $this->_is_inner_save = true;
        }

        $this->validate();

        $aql_arr = $this->getStoredAqlArray();
        if (!$aql_arr) {
            $this->_errors[] = 'Cannot save model without an aql statement.';
        }

        if ($this->_errors) {
            return $this->after_fail();
        }

        $is_insert = $this->isInsert();
        $is_update = $this->isUpdate();

        if ($is_insert && $this->methodExists('before_insert')) {
            $this->before_insert();
        }

        if ($is_update && $this->methodExists('before_update')) {
            $this->before_update();
        }

        $save_array = $this->makeSaveArray($this->_data, $aql_arr);

        if (!$save_array) {
            if (!$this->_is_inner_save) {
                $this->_errors[] = 'Error generating save array based on the model. There may be no data set.';
                return $this->after_fail();
            } else {
                return;
            }
        }

        $save_array = $this->removeIgnores($save_array);

        if (!$this->_errors) {

            if ($this->_abort_save) {
                return $this->after_save($save_array);
            }

            if (!$this->_is_inner_save) {
                $dbw->startTrans();
            }

            if ($this->methodExists('before_save')) {
                $save_array = $this->before_save($save_array);
            }

            $save_array = $this->saveArray($save_array);
            $transaction_failed = $dbw->HasFailedTrans();

            if (!$this->is_inner_save) {
                $dbw->CompleteTrans();
            }

            if ($transaction_failed) {
                return $this->_handleSaveFailure($save_array);
            } else {
                return $this->_handleSaveSuccess($save_array, $is_insert, $is_update);
            }

        }

    }

    /**
     *  @param array $save_array
     *  @return array
     *  @global $is_dev
     */
    protected function _handleSaveFailure($save_array) {
        global $is_dev;

        if (!in_array('Save Failed.', $this->_errors)) {
            $this->_errors[] = 'Save Failed.';
            if ($is_dev) {
                $this->_errors[] = 'Failure in model: ' . $this->_model_name;
                $this->_errors = array_merge($this->_errors, aql::$errors);
            }
        }

        return $this->after_fail($save_array);

    }

    /**
     *  @param  array $save_array
     *  @param  Boolean $is_insert
     *  @param  Boolean $is_update
     *  @return array
     */
    protected function _handleSaveSuccess($save_array, $is_insert = false, $is_update = false) {

        if ($this->methodExists('before_reload')) {
            $this->before_reload();
        }

        $this->reload($save_array);

        if ($is_insert) {
            $this->refreshBelongsTo();
            if ($this->methodExists('after_insert')) $this->after_insert();
        }

        if ($is_update) {
            if ($this->methodExists('after_update')) $this->after_update();
        }

        return $this->after_save($save_array);

    }

    /**
     *  internval function triggered before after_insert and after_delete,
     *  if belongs_to is defiend, it refreshes the objects defined by the array
     *
     *  model_name => constructor_field
     *
     *  IE: if this model is artist_album, which has artist_id
     *
     *      public $_belongs_to = array(
     *          'artist' => 'artist_id'
     *      );
     *
     *  @return Model   $this
     */
    protected function refreshBelongsTo() {

        if (!$this->_belongs_to || !is_assoc($this->_belongs_to)) {
            return $this;
        }

        foreach ($this->_belongs_to as $model => $field) {
            if (!$this->{$field}) continue;
            $model::refreshCache($this->{$field});
        }

        return $this;
    }

    /**
     *  aql::insert/update on the save array depending on what needs to be done
     *  recursive because of sub objects / queries
     *  @param array $save_array    array to save
     *  @param array $ids           ids to pass through
     *  @return array               updated save array
     *  @global $is_dev
     */
    public function saveArray($save_array, $ids = array()) {
        global $is_dev;
        $objects = $save_array['__objects__'];
        unset($save_array['__objects__']);
        foreach ($save_array as $table => $info) {
            foreach ($ids as $n => $v) {
                if (is_array($this->_ignore['fields']) && in_array($n, $this->_ignore['fields'])) continue;
                if (is_array($info['fields']) && !$info['fields'][$n]) {
                    $save_array[$table]['fields'][$n] = $v;
                    $info['fields'][$n] = $v;
                }
            }
            if (is_numeric($info['id'])) {
                if (is_array($info['fields']) && $info['fields']) {
                    if (!$info['fields']['update_time']) $info['fields']['update_time'] = aql::now();
                    if (defined('PERSON_ID')) {
                        if (!$info['fields']['mod__person_id']) $info['fields']['mod__person_id'] = PERSON_ID;
                        if (!$info['fields']['update__person_id']) $info['fields']['update__person_id'] = PERSON_ID;
                    }
                    aql::update($table, $info['fields'], $info['id'], true);
                }
            } else {
                if (is_array($info['fields']) && $info['fields']) {
                    $rs = aql::insert($table, $info['fields'], true);
                    if (defined('PERSON_ID') && !$info['fields']['insert__person_id']) $info['fields']['insert__person_id'] = PERSON_ID;
                    $save_array[$table]['id'] = $info['id'] = $rs[0][$table.'_id'];
                }
            }
            $ids[$table.'_id'] = $info['id'];
            if (is_array($info['subs'])) foreach ($info['subs'] as $i=>$sub) {
                $save_array[$table]['subs'][$i] = $this->saveArray($sub, $ids);
            }
        }
        if (is_array($objects)) foreach ($objects as $o) {
            if ($o['data']) {
                $tmp = Model::get($o['object']);
                $tmp->_data = $o['data'];
                $tmp->loadIDs($ids);
                $pt = $tmp->_primary_table;
                $pt_id = $pt.'_id';
                if (!$tmp->{$pt_id} && $this->$pt_id) {
                    $tmp->$pt_id = $this->$pt_id;
                }
                $return = $tmp->save(true);
                if ($return['status'] != 'OK') {
                    if (is_array($return['errors']))
                        $this->_errors = $this->_errors + $return['errors'];
                    # $this->_errors[] = "Error on Model: '{$o['object']}'";
                    $this->failTransaction();
                }
            }
        }
        $save_array['objects'] = $objects;
        return $save_array;
    }

    /**
     *  adds the properties of every the aliases in the aqlarray (table block)
     *  @param string $table
     *  @param mixed $sub
     */
    public function tableMakeProperties($table, $sub = null) {
        if (is_array($table['objects'])) foreach ($table['objects'] as $k => $v) {
            $this->addProperty($k)->$k = array();
            $this->_objects[$k] = ($v['plural']) ? 'plural' : true;
        }

        if (is_array($table['fields'])) foreach ($table['fields'] as $k => $v) {
            if (preg_match('/[\b_]id$/', $k)) $this->addProperty($k.'e');
            $this->addProperty($k);
        }

        if (is_array($table['subqueries'])) foreach($table['subqueries'] as $k => $v) {
            $this->addProperty($k)->$k = array();
        }

        $this->addProperty($table['table'].'_id');
    }

    /**
     *  transforms modelArrayObject to an array recursively
     *  @param ModelArrayObject $obj
     *  @return array
     */
    public function toArray($obj) {
        if (is_object($obj) && get_class($obj) == 'ModelArrayObject')
            $obj = $obj->getArrayCopy();

        if (is_array($obj)) foreach ($obj as $k => $v) {
            $obj[$k] = self::toArray($v);
        }
        return $obj;
    }

    /**
     *  transforms array to arrayobject recursively
     *  @param array $arr
     *  @return ModelArrayObject
     */
    public function toArrayObject($arr = array()) {
        $arr = new ModelArrayObject($arr);
        foreach ($arr as $k => $v) {
            $arr[$k] = (is_array($v)) ? self::toArrayObject($v) : $v;
        }
        return $arr;
    }

    /**
     *  @return Model       $this
     */
    public function validate() {

        # run preValidation if the method is defined
        # validation does not continue if there are errors
        if ($this->methodExists('preValidate')) $this->preValidate();
        if ($this->_errors) return $this;

        $is_update = $this->isUpdate();
        $is_insert = $this->isInsert();

        # check if this is a valid token
        if ($is_update && $this->_use_token_validation) {
            $token = $this->getToken();
            if ($token != $this->_token || !$this->_token) {
                $this->_return['token'] = $this->_token;
                $this->_errors[] = 'You do not have permission to update this record.';
                return $this;
            }
        }

        # check required fields
        foreach ($this->getRequiredFields() as $field) {
            if (!$this->fieldIsSet($field) && $is_update) continue;
            $name = ($this->_required_fields[$field]) ?: $field;
            $this->requiredField($name, $this->{$field});
        }

        # exit validation if there are errors
        if ($this->_errors) return $this;

        # check field specific validation (only if the field was set)
        foreach ($this->getProperties() as $prop) {
            if (!$this->fieldIsSet($prop)) continue;
            if (!$this->fieldHasValidation($prop)) continue;
            $this->{'set_' . $prop}($this->{$prop});
        }

        # exit validation if there are errors
        if ($this->_errors) return $this;

        # execute post validate
        if ($this->methodExists('postValidate')) $this->postValidate();

        return $this;

    }

    public function printData() {
        print_pre($this->_data);
    }

    public function printErrors() {
        print_pre($this->_errors);
    }

    /**
     *  @param string $p
     *  @return Boolean
     */
    public function propertyExists($p) {
        return array_key_exists($p, $this->_properties);
    }

    /**
     *  @param array $arr
     *  @return string  JSON
     */
    public static function returnJSON($arr = array()) {
        return json_encode($arr);
    }

    /**
     *  @return array
     */
    public function returnDataArray() {
        return $this->_data;
    }

    /**
     *  If data is not set/null, add this to errors array
     *  @param string $name
     *  @param mixed $val
     */
    public function requiredField($name, $val) {
        if (!is_null($val) && $val !== '') return;
        $this->_errors[] = sprintf(self::E_FIELD_IS_REQUIRED, $name);
    }

    /**
     *  @param string $field_name
     *  @return Boolean
     */
    public function fieldIsRequired($field_name) {
        return array_key_exists($field_name, $this->_required_fields);
    }

    /**
     *  @param string $field_name
     *  @return Boolean
     */
    public function fieldIsSet($field_name) {
        return array_key_exists($field_name, $this->_data);
    }

    /**
     *  @param string $field_name
     *  @return Boolean
     */
    public function fieldHasValidation($field_name) {
        return $this->methodExists('set_' . $field_name);
    }

    /**
     *  @return Boolean
     */
    public function isInsert() {
        return (!$this->{$this->_primary_table.'_id'});
    }

    /**
     *  @return Boolean
     */
    public function isUpdate() {
        return (!$this->isInsert());
    }

    /**
     *  @param string $val
     */
    public function validEmail($val) {
        $val = trim($val);
        if (!filter_var($val, FILTER_VALIDATE_EMAIL)) {
            $this->_errors[] = "{$val} is not a valid email address.";
        }
    }

    /**
     *  @return Boolean
     */
    public function isStaticCall() {
        if (!isset($this) && !self::isModelClass($this)) return true;
        $bt = debug_backtrace();
        return (!is_a($this, $bt[1]['class']));
    }

    /**
     *  @param array $sets  associative
     *  @return Model       $this
     */
    private function setConfig($sets = array()) {
        if (!$sets) return $this;
        $re = new ReflectionClass($this);
        $props = $re->getProperties(ReflectionProperty::IS_PROTECTED);
        foreach ($props as $prop) {
            $prop_name = $prop->getName();
            $key = substr($prop_name, 1);
            if (!array_key_exists($key, $sets)) continue;
            $this->{$prop_name} = $sets[$key];
            unset($sets[$key]);
        }
        return $this;
    }

}

/**
 *  TODO: use this for when loadDB() fails to find data
 */
class ModelNotFoundException extends Exception { }
