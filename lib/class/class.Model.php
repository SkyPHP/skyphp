<?php

if (!class_exists('ModelArrayObject')) {
	include 'class.ModelArrayObject.php';
}

class Model implements ArrayAccess {

	public static $_metadata = array();

	const E_READ_ONLY = 'The site is currently in "read only" mode. Changes have not been saved. Try again later.';
	const E_NO_METHOD_EXISTS = 'Cannot call a method that does not exist.';
	const E_METHOD_NOT_CALLABLE = 'This method is not callable.';
	const E_PROPERTY_DOES_NOT_EXIST = 'Property [%s] does not exist in this model.';
	const E_METHOD_ALREADY_DEFINED = 'Method [%s] is already defined in this model.';
	const E_FIELD_IS_REQUIRED = '%s is required.';
	const E_FIELD_IS_INVALID = '%s is invalid.';
	const E_NO_VALIDATION_CLASS = 'Cannot use this validation features without the Validation class.';

	/**
	 *	if true, the save will return after_save() without saving.
	 *	@var Boolean
	 */
	public $_abort_save = false; 

	/**
	 *	store actual .aql file when found or input aql
	 * 	@var string
	 */
	public $_aql = null; 

	/**
	 *	generated by $this->_aql
	 *	this is only set if $this->_aql is set
	 *	@var array
	 */
	public $_aql_array = array(); 

	/**
	 *	associative array of array('model_name' => 'constructor_field')
	 *	see Mode::refreshBelongsTo()
	 *	@var array
	 */
	public $_belongs_to = array();

	/**
	 *	used to compare with static::$mod_time to see if the model is outdated
	 *	@var string
	 */
	public $_cached_time = null;

	/**
	 *	stored data, corresponds to $this->_properties
	 *	@var array
	 */
	public $_data = array(); 

	/**
	 *	array of errors, if it is non empty save()/delete() will return after_fail()
	 *	@var array
	 */
	public $_errors = array();

	/**
	 *	If true, loadDB() will always bypass cache
	 *	@var Boolean
	 */
	public $_force_db = false;

	/**
	 *	Identifier set during loadDB() and reload()
	 *	@var int
	 */
	public $_id; 

	/**
	 *	settings used to ignore these fields on save
	 *	keys of arrays: tables (for joins), models (plural/singular by alias), subs
	 *	@var array
	 */
	public $_ignore = array(); 

	/**
	 *	names of objects
	 *	@var array
	 */
	public $_objects = array();

	/**
	 *	method storage used in addMethod()
	 *	@var array
	 */
	public $_methods = array();

	/**
	 *	set by class name (if is a subclass)
	 *	@var string
	 */
	public $_model_name = null;

	/**
	 *	primary table of the model
	 *	@var string
	 */
	public $_primary_table = null;

	/**
	 *	array of properties allowed to be set, generated by the model's aql statement
	 *	@var array
	 */
	public $_properties = array();

	/**
	 *	associative array of required fields array('field' => 'Display Name')
	 *	@var array
	 */
	public $_required_fields = array();

	/**
	 *	key value pairs added to/ merged with this array
	 *	will be returned in response arrays (merged)
	 *	@var array
	 */
	public $_return = array();

	/**
	 *	used to authorize updates
	 *	@var string
	 */
	public $_token = null; 

	## these are configuration properties
	## that can be set in the model __construct method $config param

	/**
	 *	if true, there will be no caching because this model has no name
	 *	@var Boolean
	 */
	protected $_aql_set_in_constructor = false;

	/**
	 *	If false, $model->_token is not required for save/delete
	 *	@var Boolean
	 */
	protected $_use_token_validation = true;

	/**
	 *	If false, sub objects caches will not be automatically refetched
	 *	@var Boolean
	 */
	protected $_refresh_sub_models = true;

	/**
	 *	used for saving sub models (not requiring token validation for inner saves)
	 *	@var Boolean
	 */
	protected $_is_inner_save = false;

	/**
	 *	Model constructor accepts arguments in a variety of ways:
	 *
	 *	$o = new artist($id);
	 *	$o = new artist($id, $conf); 			// maps to new artist($id, null, false, $conf);
	 *	$o = new artist($id, true); 			// maps to new artist($id, null, true);
	 *	$o = new artist($id, true, $conf);		// maps to new artist($id, null, true, $conf);
	 *	$o = new Model($id, $artist_aql, $conf);// maps to new Model($id, $artist_aql, false, $conf);
	 *
	 *	@param mixed $id		identifier (id, ide, or null)
	 *	@param mixed $aql		set aql for this model (if this is not a subclass)
	 *	@param mixed $force_db	if true we're loading from DB and writing to cache
	 *	@param array $config	configuration options
	 *
	 */
	public function __construct($id = null, $aql = null, $force_db = false, $config = array()) {
		
		# map arguments to correct vars
		list($aql, $force_db, $config) = $this->mapConstructArgs($aql, $force_db, $config);
		
		# initialize this model
		$this->_model_name = get_class($this);
		$this->_getModelAql($aql)->makeProperties();

		# set if we're refreshing it
		$this->_force_db = ($force_db || $_GET['refresh']);
		
		# set configuration options for 
		$this->setConfig($config);

		# load from DB if $id is set proper, otherwise throw Exception
		$this->checkConstructorID($id, $force_db);
		
		# run construct hook
		$this->construct();
	} 


	/**
	 *	checks for a proper identifier, loads object if set
	 *	@param mixed $id 			identifier
	 *	@param Boolean $force_db 	force db read
	 */
	protected function checkConstructorID($id = null, $force_db = false) {
		if (!$id) return;
		$e = 'The model __construct method does not support %s as a first argument. '
		   . 'Only: null|false|numeric|IDE';
		if (!is_string($id) && !is_numeric($id)) {
			throw new Exception(sprintf($e, gettype($id)));
		}
		$this->loadDB($id, $force_db);
		$this->_token = $this->getToken();
	}


	/**
	 *	maps constructor arguments to a standard format by type
	 *	@param mixed $aql
	 *	@param mixed $force_db
	 *	@param mixed $config
	 * 	@return array 
	 */
	protected function mapConstructArgs($aql = null, $force_db = false, $config = array()) {
		
		if (is_array($force_db)) {
			$config = $force_db;
			$force_db = false;
		}

		if (is_array($aql)) {
			$config = $aql;
			$aql = null;
		} else if (is_bool($aql)) {
			$force_db = $aql;
			$aql = null;
		}

		# return fixed and uniform arguments
		return array($aql, $force_db, $config);
	}

	/**
	 *	so as to not use method exists
	 *	@return Model $this
	 */
	public function construct() { return $this; }

	public function __call($method, $params) {
		if (!$this->methodExists($method)) throw new Exception(self::E_NO_METHOD_EXISTS);
		if (!is_callable($this->_methods[$method])) throw new Exception(self::E_METHOD_NOT_CALLABLE);
		return call_user_func_array($this->_methods[$method], $params);
	}

	/**
	 *	if this model is called as a function, return dataToArray();
	 *		ex: $o = new artist;
	 *			$o(); # equivalent to $o->dataToArray();
	 *	@return array
	 */
	public function __invoke() {
		return $this->dataToArray();
	}


	/**
	 *	Maps uses _getField as a magic getter if property exists
	 * 	@param string $name
	 *	@return mixed
	 */
	final public function __get($name) {
		return ($this->propertyExists($name))
			? $this->_getField($name)
			: null;
	}

	/**
	 *	@param string $name
	 *	@return mixed
	 */
	protected function _getField($name) {
		return $this->_data[$name];
	}

	/**
	 *	Magic Setter -- sets values to $this->_data
	 *	If $name looks like an ide, the ID version is set
	 * 	Adds to errors if setting an invalid property
	 *
	 *	@param string $name
	 *	@param mixed $value
	 *	@return Model $this
	 */
	public function __set($name, $value) {
		
		# check to see if this is a valid property or IDE
		$is_ide = preg_match('/_ide$/', $name);
		if (!$this->propertyExists($name) && !$is_ide) {
			$this->_errors[] = sprintf(self::E_PROPERTY_DOES_NOT_EXIST, $name);
			return $this;
		}

		# if this is an IDE we add it as a property to the object
		if (!$this->propertyExists($name)) $this->addProperty($name);

		# cast to array or to ModelArrayObject as necessary
		$value = $this->prepSetValue($value);

		$this->_data[$name] = $value;

		#if is IDE, add as an ID as well
		if ($is_ide) {
			$key = aql::get_decrypt_key($name); # decrypt ide
			$n_name = substr($name, 0, -1); 	# remove e (from ide)
			$this->_data[$n_name] = decrypt($value, $key); 
		}

		return $this;
	}

	/**
	 *	cast value to array if it is a stdClass
	 *	to arrayobject if it is an array otherwise return it as it was
	 *	@param mixed $val
	 *	@return mixed
	 */
	private function prepSetValue($val) {
		if (!is_array($val) && !is_object($val)) return $val;
		if (is_array($val)) return self::toArrayObject($val);
		if (get_class($val) == 'stdClass') return (array) $val;
		return $val;
	}

	/**
	 *	casting a Model to a string returns $this->getID()
	 *	@return string
	 */
	public function __toString() {
		return (string) $this->getID();
	}

	/**
	 *	This will trigger aborting of $this->save();
	 *	Validation still happens, and response is returned (after_fail or after_save)
	 *	@return Model $this
	 */
	public function abortSave() {
		$this->_abort_save = true;
		return $this;
	}


	/**
	 *	merge to the required fields array
	 *	@param array $arr 		associative array
	 *	@throws Exception
	 *	@return Model
	 */
	public function addRequiredFields($arr = array()) {
		if (!is_assoc($arr)) {
			throw new Exception('Model::addRequiredFields expects an associative array with field => return name.');
		}
		$this->_required_fields = array_merge($this->_required_fields, $arr);
		return $this;
	}

	/**
	 *	add any number of properties to the object
	 * 	@param string	(any number of arguments)
	 *	@return Model $this
	*/
	public function addProperty() {
		$num_args = func_num_args();
		$args = func_get_args();
		for ($i = 0; $i < $num_args; $i++) {
			$this->_properties[$args[$i]] = true;
		}
		return $this;
	}


	/**
	 *	alias for Model::addProperty()
	 *	@return Model $this
	 */
	public function addProperties() {
		$args = func_get_args();
		call_user_func_array(array($this, 'addProperty'), $args);
		return $this;
	}

	/**
	 *	add a method to this model
	 *		usage:
	 *			$model->addMethod('testing', function($arg) use($model) {
	 *				// body
	 *			});
	 *			$model->testing($somearg);
	 *	@param string $name
	 *	@param callback $fn
	 *	@return Model $this
	 */
	public function addMethod($name, $fn) {
		
		if ($this->methodExists($name)) {
			throw new Exception(sprintf(self::E_METHOD_ALREADY_DEFINED, $name));
		}

		$this->_methods[$name] = $fn;
		return $this;
	}

	/**
	 *	@param string $name
	 *	@return bool
	 */
	public function methodExists($name) {
		return (method_exists($this, $name)) 
			?: array_key_exists($name, $this->_methods);
	}

	/**
	 * 	plural subobject specific "array_map", because these are not arrays
	 *	if the model has [sub_model]s
	 *	$model->mapSubObjects('sub_model', $callback)
	 *	
	 *	@param string $name 				object name
	 *	@param callback $fn 				defaults to null
	 *	@param Boolean $skip_id_filter		skip is filter, defaults to false
	 *	@return array 						like in array map
	 *
 	 * 	@throws Exception
	 */
	public function mapSubObjects($name, $fn = null, $skip_id_filter = false) {
		
		if (!$this->isPluralObject($name)) {
			throw new Exception('mapSubObjects expects a valid plural object param.');
		}

		$re = array();
		foreach ($this->$name as $o) {
			if (!$skip_id_filter && !$o->getID()) continue;
			$re[] = ($fn) ? $fn($o) : $o;
		}
		return $re;
	}

	/**
	 * 	@param array $arr 	the save array
	 * 	@return array 		response array
	 */
	public function after_fail($arr = array()) {
		return array_merge(array(
			'status' => 'Error',
			'errors' => $this->_errors,
			'data' => $this->dataToArray(true)
		), $this->_return);
	}

	/**
	 *	@param array $arr	the save array
	 *	@return array 		response array
	 */
	public function after_save($arr = array()) {
		return array_merge(array(
			'status' => 'OK',
			'data' => $this->dataToArray(true),
			'_token' => $this->getToken()
		), $this->_return);
	}

	/**
	 *	@return Boolean
	 */
	public function hasRequiredFields() {
		return (bool) (count($this->getRequiredFields() > 0));
	}

	/**
	 *	@return array
	 */
	public function getRequiredFields() {
		return array_keys($this->_required_fields);
	}

	/**
	 *	@return mixed 	numeric or null
	 */
	public function getID() {
		$field = $this->getPrimaryTable() . '_id';
		$field_ide = $field . 'e' ;
		return $this->{$field} = ($this->{$field}) 
			?: (($this->{$field_ide}) 
				? decrypt($this->{$field_ide}, $this->_primary_table)
				: null);
	}

	/**
	 *	@return mixed 	string or null
	 */
	public function getIDE() {
		$field = $this->getPrimaryTable() . '_id';
		$field_ide = $field . 'e';
		return ($this->{$field_ide}) 
			?: (($this->{$field})
				? encrypt($this->{$field}, $this->_primary_table)
				: null);
	}
	
	/**
	 * 	Uses required fields to fetch the identifier of the object if it is not set
	 *	Should generally be used in postValidate() for a uniqueness constraint on the 
	 *	required fields
	 * 	This sets $this->{primary_table_id}
	 * 
	 * 	@return Model
	 */
	public function getIDByRequiredFields() {

		# if there are errors | have ID | no required fields return 
		if ($this->_errors || $this->getID() || !$this->hasRequiredFields()) {
			return $this;
		}

		# set up
		$where = array();
		$clause = array('limit' => 1, 'where' => &$where);
		$aql = sprintf('%s { }', $this->getPrimaryTable());
		$key = $this->getPrimaryTable() . '_id';

		# make where
		foreach ($this->getRequiredFields() as $f) {
			$where[] = sprintf("%s = '%s'", $f, $this->{$f});
		}

		$rs = aql::select($aql, $clause);
		$this->{$key} = ($rs[0][$key]) ?: $this->{$key};
		$this->_token = ($this->_token) ?: $this->getToken();

		return $this;
	}

	/**
	 *	Use to repopulate required fields from the database on save. 
	 *	Only sets them if they are empty.
	 *	Must be called within a model. Best to use in preValidate(), 
	 *	if the object must be unique.
	 *
	 * 	@param int $id		defaults to $this->getID(), exits if not present
	 *	@return Model
	 */
	public function preFetchRequiredFields($id = null) {
		$id = ($id) ?: $this->getID();
		if (!$id) return $this;
		
		$keys = $this->getRequiredFields();
		
		$continue = false;
		foreach ($keys as $f) {
			if (!$this->fieldIsSet($f)) {
				$continue = true;
				break;
			}
		}

		# return if all required fields are already set
		if (!$continue) return $this;

		# get data
		$r = aql::profile($this->getStoredAqlArray(), $id);
		if ($r) foreach ($keys as $f) {
			if (!$this->fieldIsSet($f)) $this->_data[$f] = $r[$f];	
		}

		return $this;
	}

	/**
	 *	returns $this->_data in array form 
	 *	we use ModelArrayObjects instead of arrays and these need to get converted back
	 *
	 *	@param Boolean	$hide_ids	if true, remove "_id" fields (keep _ides), default false
	 *	@return array
	 */
	public function dataToArray($hide_ids = false) {
		$return = array();
		if (!$arr) $arr = $this->_data;
		foreach ($arr as $k => $v) {
			if ($this->_objects[$k] === 'plural') {
				foreach ($v as $i => $o) {
					if (self::isModelClass($o)) $return[$k][$i] = $o->dataToArray($hide_ids);
				}
			} else if ($this->_objects[$k] && get_class($v) != 'ModelArrayObject') {
				$return[$k] = $v->dataToArray($hide_ids);
			} else if (is_object($v) && get_class($v) == 'ModelArrayObject') {
				$return[$k] = self::dataToArraySubQuery($v);
			} else {
				$is_id = (substr($k, -3) == '_id');
				if (!$is_id || !$hide_ids) {
					$return[$k] = $v;
				}
			}
		}
		unset($arr);
		return $return;
	}

	/**
	 *	Helper for Model::dataToArray() for when this is a ModelArrayObject
	 *	@param array $arr
	 *	@param Boolean
	 */
	public function dataToArraySubQuery($arr = array(), $hide_ids = false) {
		$return = array();
		foreach ($arr as $k => $v) {
			if (is_object($v) && self::isModelClass($v)) {
				$return[$k] = $v->dataToArray($hide_ids);
			} elseif (is_object($v) && get_class($v) == 'ModelArrayObject') {
				$return[$k] = self::dataToArraySubQuery($v, $hide_ids);
			} else {
				if (is_object($v)) $v = (array) $v;
				$is_id = (substr($k, -3) == '_id');
				if (!$is_id || !$hide_ids) {
					$return[$k] = $v;
				}
			}
		}
		unset($arr);
		return $return;
	}

	
	/**
	 *	Deletes the current record if there is a token and identifier 
	 *	by setting active = 0
	 *	and clears memcache 
	 *	
	 *	Triggers events: before_delete and after_delete
	 *	Refreshes $this->_belongs_to
	 *	
	 *	@return array 	the response array (after_fail or after_save)
	 *	@global $model_dependencies
	 */
	public function delete() {
		
		$id = $this->getID();

		if ($this->_token != Model::generateToken($id, $this->_primary_table) || !$this->_token) {
			$this->_errors[] = 'You do not have permission to remove this record.';
		}

		if (!$id) {
			$this->_errors[] = 'Identifier is not set, there is nothing to delete.';
		}

		if ($this->_errors) {
			return $this->after_fail();
		}
		
		$now = aql::now();
		
		$fields = array(
			'active' => 0,
			'mod_time' => $now,
			'update_time' => $now
		);

		if (defined('PERSON_ID') && PERSON_ID) {
			$fields['mod__person_id'] = $fields['update__person_id'] = PERSON_ID;
		}

		// load the object 
		// so that we have the information left over for after_delete hooks
		$this->loadDB($id);

		if ($this->methodExists('before_delete')) {
			$this->before_delete();
		}

		if (aql::update($this->_primary_table, $fields, $id)) {
			
			// clears the memcache of stored objects of this identifier.
			$delete_key = function($m) use($id) {
				$key = sprintf('%s:loadDB:%d', $m, $id);
				mem($key, null);	
			};

			if ($this->_model_name != 'Model') {
				global $model_dependencies;
				$delete_key($this->_model_name);
				if (is_array($model_dependencies[$this->_primary_table])) {
					foreach ($model_dependencies[$this->_primary_table] as $m) {
						$delete_key($m);
					}
				}
			}

			if ($this->methodExists('after_delete')) {
				$this->after_delete();
			}

			$this->refreshBelongsTo();

			return array('status' => 'OK');

		} else {
			$this->_errors[] = 'Error Deleting.';
			return $this->after_fail();
		}
		
	}

	/**
	 *	@param string $ext 	extension for file, default: php
	 *	@return string 		path to form file with given extension
	 *	@global $sky_aql_model_path
	 */
	public function getFormPath($ext = 'php') {
		global $sky_aql_model_path;
		$format = '%s%s/form.%s.%s';
		$with = array($sky_aql_model_path, $this->_model_name, $this->_model_name, $ext);
		return vsprintf($format, $with);
	}

	/**
	 * 	Includes the form file (path/to/models/Model/form.Model.php) in $this scope
	 *	@return Model
	 *	@throws	Exception
	 */
	public function includeForm() {
		$path = $this->getFormPath();
		if (!file_exists_incpath($path)) {
			throw new Exception("Form file [{$path}] does not exist for this model");
		}
		$r = $o = $this;
		include $path;
		return $this;
	}

	/**
	 *	Triggers DBW transaction failure
	 *	@global $dbw
	 */
	public function failTransaction() {
		global $dbw;
		$dbw->FailTrans();
	}

	/**
	 *	runs generic validation on the field given using Validation class in CMS.
	 *
	 *	@param 	string $field 		name of the field
	 *	@param 	string $name 		display name of the field, used for errors
	 *	@param 	string $val			value of the field
	 *	@param 	string $fn			name of the method to use in validation class
	 *	@param 	boolean $replace	if true, replace the value given with return of 
	 *								ValidationMethod
	 *
	 *	@throws Exception
	 */
	public function genericValidation($field, $name, $val, $fn, $replace = false) {
		
		if (!class_exists('validation')) {
			throw new Exception(self::E_NO_VALIDATION_CLASS);
		}

		# exit if we can't call this function
		if (!$field || !$name || !is_callable('validation', $fn) || !$val) return;

		$valid = validation::$fn($val);

		if (!$valid) {
			$this->_errors[] = sprintf(self::E_FIELD_IS_INVALID, $name);
		} else if ($replace) {
			$this->_data[$field] = $valid;
		}

	}

	/**
	 *	@param string $str 			model name
	 *	@param mixed $id			identifier (id, ide)
	 *	@param Boolean $force_db	force_db read, defaults to false
	 *	@return Model
	 *
	 *	@throws Exception
	 */
	public static function get($str = null, $id = null, $force_db = false) {
		
		if (!is_string($str)) {
			throw new Exception('Model name or AQL must be specified when using Model::get()');
		}

		# get class if it exists
		aql::include_class_by_name($str);
		return (class_exists($str))
			? new $str($id, null, $force_db)
			: new Model($id, $str);

	}


	/**
	 *	Does not check the cache for the object, 
	 *	reads directly from DB and writes to cache.
	 *	@param mixed $id	identifier (id, ide)
	 *	@return Model
	 *	@throws Exception
	 */
	public static function refreshCache($id) {
		$class = get_called_class();
		
		if ($class == 'Model') {
			throw new Exception('Model::refreshCache needs to be called on a subclass');
		}

		return new $class($id, null, true);
	}

	/**
	 *	example:
	 *		if the model is:
	 *			artist {
	 *				... fields
	 *				[artist_album]s,
	 *				[artist_genre]s,
	 *				[artist_label]
	 *			}
	 *		php:
	 *		$o = artist::getPartial($id, array(
	 *			'artist_label' => true,
	 *			'artist_album' => array(
	 *				'artist_album_label' => true
	 *			)
	 *		));
	 *	@param mixed $id		identifier (id, ide)
	 *	@param array $refresh	associative array of values to refresh 
	 *							(multidimentional possibly)
	 *	@return Model
	 */
	public static function getPartial($id = null, $refresh = array()) {
		
		$cl = get_called_class();
		
		$o = new $cl($id, null, false, array(
			'refresh_sub_models' => false
		));

		if (is_array($refresh)) foreach ($refresh as $k => $v) {
			if (!$o->isObjectParam($k)) continue;
			if ($o->isPluralObject($k)) {
				foreach ($o->{$k} as $key => $sub) {
					$class = get_class($sub);
					$o->$k[$key] = $class::getPartial($sub->getID(), $v);
				}
			} else {
				$class = get_class($o->$k);
				$o->$k = $class::getPartial($o->$k->getID(), $v);
			}
		}

		return $o;

	}

	/**
	 *	get the name of hte object if it has an alias
	 *	@param string	$str	object alias
	 *	@return mixed 			string or null (if not found)
	 */
	public function getActualObjectName($str) {
		if (!$this->isObjectParam($str)) return null;
		foreach ($this->getStoredAqlArray() as $table) {
			if ($table['objects'][$str]) {
				return $table['objects'][$str]['model'];
			}
		}
		return null;
	}

	/**
	 *	@return string 		AQL statement of calling class
	 */
	public static function getAQL() {
		$c = get_called_class();
		return self::_getAql($c);
	}

	/**
	 *	sets model name based on aql, sets this as a tmp model (_aql_set_in_constructor)
	 *	@param string $aql		aql statemnt or empty
	 *	@return Model
	 */
	public function _getModelAql($aql = null) {
		if ($this->getStoredAql()) return $this;
		if (!$aql) { $this->_getAql($this->_model_name); } 
		else if (aql::is_aql($aql)) { $this->_aql = $aql; $this->_aql_set_in_constructor = true; } 
		else { $this->_model_name = $aql; $this->_getAql($this->_model_name); }
		return $this;
	}

	/**
	 *	@return string 		get model aql statement
	 */
	public function getStoredAql() {
		return (aql2array::$aqls[$this->_model_name]) ?: $this->_aql;
	}

	/**
	 * 	@return array 		get model aqlarray (parsed aql)
	 */
	public function getStoredAqlArray() {
		return (aql2array::$aqlArrays[$this->_model_name]) ?: $this->_aql_array;
	}

	/**
	 *	@param string $model_name		name of model
	 *	@return string 					aql statemnt
	 */
	public function _getAql($model_name) {
		return if_not(aql2array::$aqls[$model_name], function() use($model_name) {
			return aql2array::$aqls[$model_name] = aql::get_aql($model_name);
		});
	}

	/**
	 *	returns an array of objects or one object if limit is set to 1
	 *	@param array $clause		clause array
	 *	@param string $model_name	model name, if null, using called class
	 *	@return mixed 	if limit => 1, object or null, otherwise an array (can be empty)
	 */
	public static function getByClause($clause, $model_name = null) {
		$model_name = ($model_name) ?: self::getCalledClass();
		if (!$model_name || $model_name == 'Model') {
			throw new Exception('Model::getByClause expects a second parameter of model_name.');
		}
		if (!$clause['where']) {
			throw new Exception('Model::getByClause expects a where clause.');
		}
		$rs = aql::select(aql::get_min_aql_from_model($model_name), $clause);
		foreach ($rs as $k => $v) {
			$rs[$k] = new $model_name($v['id']);
		}
		return ($clause['limit'] === 1) ? $rs[0] : $rs;
	}

	/**
	 *	return array of objects matching the criteria specified
	 *	@param array $clause
	 *	@return array of Model objects
	 */
	public static function getMany() {
		return call_user_func_array(array(get_called_class(),'getByClause'), func_get_args());
	}

	/**
	 *	return a single object matching the criteria specified
	 *	@param array $clause
	 *	@return Model
	 */
	public static function getOne() {
		return call_user_func_array(array(get_called_class(),'getByClause'), func_get_args());
	}

	/**
	 *	return the count of objects matching the criteria specified
	 *	@param array $clause
	 *	@return int 
	 */
	public static function count($c=array()) {
		return call_user_func(array(get_called_class(),'getList'), $c, true);
	}

	/**
	 * 	returns an array of ids
	 *	@param array $clause			clause array
	 *	@param Boolean $do_count 		if true, returns a count of the list
	 *	@return array
	 */
	public static function getList($clause = array(), $do_count = false) {
		$model_name = self::getCalledClass();
		if (!$model_name || $model_name == 'Model') {
			throw new Exception("Model::getList expects a clause array as a parameter.");
		}
		$sql = aql::sql(aql::get_aql($model_name), $clause);
		if ($do_count) {
			$r = sql($sql['sql_count']);
			return $r->Fields('count');
		} else {
			$ids = array();
			$r = sql($sql['sql_list']);
			while (!$r->EOF) {
				$ids[] = $r->Fields('id');
				$r->moveNext();
			}
			return $ids;
		}

	}

	/**
	 *	to be used on an instantiated object
	 *	@param mixed $id 				identifier(id, ide), default: $this->getID()
	 *	@param string $primary_table	primary_table, default: $this->getPrimaryTable()
	 * 	@return mixed 					string or null
	 */
	public function getToken($id = null, $primary_table = null) {
		$primary_table = ($primary_table) ?: $this->getPrimaryTable();
		if ($id && !is_numeric($id)) $id = decrypt($id, $primary_table);
		$id = ($id) ?: $this->getID();
		return self::_makeToken($id, $primary_table);
	}

	/**
	 *	to be used statically
	 *	@param mixed $id				identifier (id, ide)
	 *	@param string $primary_table	primary_table, default to get called class
	 * 	@return mixed 					string or null
	 */
	public static function generateToken($id = null, $primary_table = null) {
		
		if (!$primary_table) {
			$cl = get_called_class();
			$o = new $cl;
			return $o->getToken($id);
		}

		if ($id && !is_numeric($id)) $id = decrypt($id, $primary_table);
		return self::_makeToken($id, $primary_table);
	}

	/**
	 *	@param int $id
	 *	@param string $table
	 *	@return mixed 		string or null
	 */
	private static function _makeToken($id, $table) {
		if (!$id || !$table) return null;
		return encrypt($id, encrypt($id, $table));
	}

	/**
	 *	@return mixed 		string or null (class name)
	 */
	public function getCalledClass() {
		if (!self::isStaticCall()) return get_class($this);
		return (function_exists('get_called_class'))
			? get_called_class()
			: null;
	}

	/**
	 *	@return array
	 */
	public function getAqlArray() {
		return $this->getStoredAqlArray();
	}

	/**
	 *	returns model name or stored aql depending on if it is a temp model or not
	 *	@return string
	 */
	public function getModel() {
		return $this->getStoredAql();
	}

	/**
	 *	returns model name or aql array depending on if its a temp model
	 *	@return mixed 		array or string
	 */
	public function getModelName() {
		return (get_class($this) == 'Model')
			? $this->getStoredAqlArray()
			: $this->_model_name;
	}

	/**
	 *	@return string
	 */
	public function getPrimaryTable() {
		return $this->_primary_table;
	}

	/**
	 *	@return array
	 */
	public function getProperties() {
		return array_keys($this->_properties);
	}

	/**
	 *	@param Object $class
	 *	@return Boolean
	 */
	public static function isModelClass($class) {
		return (is_a($class, 'Model'));
	}
	
	/**
	 *	@param string $str		property name
	 *	@return Boolean
	 */
	public function isObjectParam($str) {
		return array_key_exists($str, $this->_objects);
	}

	/**
	 *	@param string $str		property name
	 *	@return Boolean
	 */
	public function isPluralObject($str) {
		return ($this->isObjectParam($str))
			? ($this->_objects[$str] === 'plural')
			: false;
	}

	/**
	 *	@param string $str		property name
	 *	@return Boolean
	 */
	public function isSingleObject($str) {
		return ($this->isObjectParam($str) && !$this->isPluralObject($str));
	}

	/**
	 *	Properly loads an associative array of properties into the object
	 *	decrypting ides if necessary
	 *	creating objects if necessary
	 * 
	 *	@param array $array
	 *	@return Model 		$this
	 */
	public function loadArray($array = array()) {
		if (!$array) $array = $_POST;
		if (is_array($array)) foreach ($array as $k => $v) {
			if ($k == '_token') {
				$this->{$k} = $v;
			} else if ($this->propertyExists($k) || preg_match('/(_|\b)id(e)*?$/', $k)) {
				if ($this->isObjectParam($k)) { 
					$obj = $this->getActualObjectName($k);
					aql::include_class_by_name($obj);
					if ($this->_objects[$k] === 'plural') {
						foreach ($v as $key => $arr) {
							if (is_array($arr)) {
								$this->_data[$k][$key] = (class_exists($obj))
									? new $obj()
									: new Model(null, $obj);
								$this->_data[$k][$key]->loadArray($arr);
							} else {
								$this->_data[$k][$key] = $arr;
							}
						}
						$this->_data[$k] = new ModelArrayObject($this->_data[$k]);
					} else {
						if (is_array($v)) {
							$this->_data[$k] = (class_exists($obj))
								? new $obj()
								: new Model(null, $obj);
							$this->_data[$k]->loadArray($v);
						} else {
							$this->_data[$k] = $v;
						}
					}
				} else if (is_array($v)) {
					$this->_data[$k] = $this->toArrayObject($v);
				} else {
					if (substr($k, -4) == '_ide') {
						$d = aql::get_decrypt_key($k);
						$decrypted = decrypt($v, $d);
						$field = substr($k, 0, -1);
						$this->_data[$field] = $decrypted;
						$this->_properties[$field] = true;
					}
					$this->_data[$k] = $v;
					if (!$this->propertyExists($k)) $this->_properties[$k] = true;
				}
			} 
		}
		return $this;
	}

	/**
	 *	@param Model $o
	 *	@return Boolean
	 */
	public static function cacheExpired($o) {
		
		$mod_time = (isset($o::$mod_time))
			? $o::$mod_time
			: null;

		if (!$mod_time) return false;
		if (!$o->_cached_time) return true;

		$is_expired = (bool) (strtotime($o->_cached_time) <= strtotime($mod_time));
		elapsed('cacheExpired:' . var_export($is_expired, true));
		return $is_expired;

	}

	/**
	 *	@param mixed $id	identifier(id, ide), default: $this->getID()
	 *	@return string
	 */
	public function getMemKey($id = null) {

		$id = ($id) ?: $this->getID();
		if (!$id) return null;

		$v = (isset($this::$mod_time))
			? ':v' . strtotime($this::$mod_time)
			: null;

		return $this->_model_name . ':loadDB' . $v . ':' . $id;

	}

	/**
	 *	Attempts to fetch data from cache, sets the object, 
	 *	otherwise, reads from db, sets the object and cache
	 *
	 *	@param mixed $id			identifier(id, ide)
	 *	@param Boolean $force_db	force db read, default: false
	 * 	@param Boolean $use_dbw		force master db read, default: false
	 * 	@return Model 	$this
	 */
	public function loadDB($id, $force_db = false, $use_dbw = false) {
		
		$id = (!is_numeric($id)) 
			? decrypt($id, $this->getPrimaryTable())
			: $id;

		if (!$id) $this->_errors[] = 'Invalid Identifier passed to loadDB()';

		$mem_key = $this->getMemKey($id);
		if (!$mem_key) $this->_errors[] = 'Could not generate cache key.';

		# exit early if load will fail
		if ($this->_errors) return $this;

		# set booleans
		$reload_subs = false;
		$force_db = ($force_db || $this->_force_db || $_GET['refresh']) ? true : false;
		$is_subclass = ($this->_model_name != 'Model');

		# if reloading from DB, make sure we're doing it form Master, not slave.
		if ($force_db || $use_dbw) { $use_dbw = true; global $dbw; }
		$db_conn = ($use_dbw) ? $dbw : null;

		# for lexical binding with anonymous funcitons.
		$that = $this; 

		# function that reads and sets data
		$load = function($mem_key = null) use($that, $db_conn, $id) {
			$o = aql::profile($that->getModelName(), $id, true, $that->_aql, true, $db_conn);
			if ($mem_key)  { 	$o->_cached_time = date('c'); mem($mem_key, $o); 	}
			return $o;
		};

		if (!$force_db && $is_subclass) { 
			$o = mem($mem_key);			# do a normal get from cache
			if (!$o->_data || self::cacheExpired($o)) {
				$o = $load($mem_key);	# if cache not found or expired, load from DB
			} else {
				$reload_subs = true;	# we will be reloading submodels
			}
		} else if ($force_db && $is_subclass && !$this->_aql_set_in_constructor) { 
			$o = $load($mem_key);		# refresh was specified
		} else { 
			$o = $load();				# this is a temp model, fetch from db
		}

		if (self::isModelClass($o) && is_array($o->_data)) { 
			
			# we have a proper object fetched, update the data in $this using $o
			$arr = array('data', 'properties', 'objects');
			
			array_walk($arr, function($key) use($o, $that) {
				$k = '_' . $key;
				$that->$k = array_merge($that->$k, $o->$k);
			});
			
			$this->_id = $id;
			$this->_cached_time = $o->_cached_time;

			if ($reload_subs) $this->reloadSubs($use_dbw);

		} else {
			$this->_errors[] = 'No data found for this identifier.';
		}

		return $this;

	}

	/**
	 *	Used during save to pass created ids down to subobjects if the property exists
	 *	@param array $ids		associative of id_field => value
	 *	@return Model 			$this
	 */
	public function loadIDs($ids = array()) {
		foreach ($ids as $k => $v) {
			if (!$this->_data[$k] && $this->propertyExists($k)) $this->_data[$k] = $v;
		}
		return $this;
	}

	/**
	 *	@param string $json
	 *	@return Model $this
	 */
	public function loadJSON($json) {
		$array = json_decode($json, true);
		if (is_array($array)) return $this->loadArray($array);
		$this->_errors[] = 'ERROR Loading JSON. JSON was not valid.';
		return $this;
	}


	/**
	 *	Creates and stores the parsed AQL array
	 */
	public function makeAqlArray() {
		if ($this->_model_name == 'Model' || !$this->_model_name) {
			$this->_aql_array = aql2array($this->_aql);
		} else {
			self::$_metadata[$this->_model_name]['aql_array'] = &aql2array::get($this->_model_name, $this->getStoredAql());
		}
	}

	/**
	 *	makes a foreign key array from the aql array
	 *	used to figure out in what order saves will happen if there are joins
	 *	@param array $aql_array
	 *	@return array
	 */
	public function makeFKArray($aql_array) {
		$fk = array();
		foreach ($aql_array as $k => $v) {
			if (is_array($v['fk'])) foreach ($v['fk'] as $f) {
				$fk[$f][] = $v['table']	;
			}
		}
		return $fk;
	}


	/**
	 *	Recursively construct an array with key (table name), value (fields, id)
	 *	to use in aql::insert() and aql::update()
	 *	sets __objects__ key for subobjects
	 *	sets subs for nested aql
	 *	
	 *	@param array $data_array		defaults to $this->_data
	 *	@param array $aql_array 		defaults to $this->getStoredAqlArray()
	 *	@return array
	 */
	public function makeSaveArray($data_array = array(), $aql_array = array()) {
		if (!$data_array && !$aql_array) {
			$data_array = $this->_data;
			$aql_array = $this->getStoredAqlArray();
		}
		$tmp = array();
		if (is_array($data_array)) foreach($data_array as $k => $d) {
			if (!is_object($d) && !$this->isObjectParam($k)) { // this query
				foreach ($aql_array as $table => $info) {
					if ($info['fields'][$k]) {
						$field_name = substr($info['fields'][$k], strpos($info['fields'][$k], '.') + 1);
						if ($tmp[$info['table']]['fields'][$field_name] != 'id') $tmp[$info['table']]['fields'][$field_name] = $d;
						else $tmp[$info['table']]['id'] = $d;
					} else if (substr($k, '-4') == '_ide') {
						if (substr($k, 0, -4) == $info['table']) {
							$tmp[$info['table']]['id'] = decrypt($d, $info['table']);
						}
					} else if (substr($k, '-3') == '_id') {
						$table_name = explode('__', substr($k, 0, -3));
						$table_name = ($table_name[1]) ? $table_name[1] : $table_name[0];
						if ($info['table'] == $table_name && $d !== NULL) {
							$tmp[$info['table']]['id'] = $d;
						}
					}
				}
			} else if ($this->isObjectParam($k)) { // sub objects
				if ($this->_objects[$k] === 'plural') {
					foreach ($d as $i => $v) {
						$tmp['__objects__'][] = array('object' => get_class($v), 'data' => $v->_data);
					}
				} else {
					$tmp['__objects__'][] = array('object' => get_class($d), 'data' => $d->_data);
				}
			} else { // sub queries
				$d = $this->toArray($d);
				foreach ($aql_array as $table => $info) {
					if (is_array($info['subqueries'])) foreach($info['subqueries'] as $sub_k => $sub_v) {
						if ($k == $sub_k) {
							foreach ($d as $i => $s) {
								if (is_object($s) && get_class($s) == 'stdClass') $s = (array) $s;
								$tmp[$info['table']]['subs'][] = $this->makeSaveArray($s, $sub_v);
							}
							break;
						}
					}
				}
			}
		}
		// make sure that the array is in the correct order
		$fk = self::makeFKArray($aql_array);
		unset($aql_array); unset($data_array);
		return self::makeSaveArrayOrder($tmp, $fk);
	}

	/**
	 *	reorders the saveArray based on the foreign keys
	 *	@param array $save_array 		saveArray
	 *	@param array $fk				foreign key array
	 *	@return array
	 */
	public function makeSaveArrayOrder($save_array, $fk) {
		$return_array = array();
		$first = array(); // prepends to return array
		foreach ($fk as $parent => $subs) {
			foreach ($subs as $dependent) {
				if ($save_array[$dependent]) {
					if (!array_key_exists($dependent, $fk)) {
						$return_array[$dependent] = $save_array[$dependent];
						unset($save_array[$dependent]);
					} else {
						$return_array = array($dependent => $save_array[$dependent]) + $return_array;
						unset($save_array[$dependent]);
					}
				}
			}
		}
		return $save_array + $return_array;
	}

	/**
	 *	removes $this->_ignore props from the save array
	 *	@param array $save_array	save array
	 *	@return array 				filtered save array
	 */
	public function removeIgnores($save_array = array()) {
		if (!$this->_ignore) return $save_array;

		// remove tables
		if (is_array($this->_ignore['tables'])) {
			foreach ($this->_ignore['tables'] as $remove) {
				if (!array_key_exists($remove, $save_array)) continue;
				unset($save_array[$remove]);
			}
		}

		// remove objects
		if (is_array($this->_ignore['objects']) && $save_array['__objects__']) {
			foreach ($this->_ignore['objects'] as $remove) {
				foreach ($save_array['__objects__'] as $k => $v) {
					if ($v['object'] == $remove) {
						unset($save_array['__objects__'][$k]);
					}
				}
			}
		}

		// remove subs
		if (is_array($this->_ignore['subs'])) {
			foreach ($this->_ignore['subs'] as $remove) {
				foreach ($save_array as $i => $k) {
					if (is_array($k['subs'])) foreach ($k['subs'] as $n => $sub) {
						if (array_key_exists($remove, $sub)) {
							unset($save_array[$i]['subs'][$n]);
						} // endif exists
					} // end subs
				} // end tables
			} // end removes
		}

		// remove fields
		if (is_array($this->_ignore['fields'])) {
			foreach ($this->_ignore['fields'] as $remove) {
				foreach($save_array as $k => $v) {
					if (!is_array($v['fields']) || !array_key_exists($remove, $v['fields'])) continue;
					unset($save_array[$k]['fields'][$remove]);
				}
			}
		}
		return $save_array;
	}

	/**
	 *	@return Model 		$this
	 *	@throws Exception
	 */
	public function makeProperties() {
		if ($this->getStoredAql()) {
			$this->makeAqlArray();
			$i = 0;
			foreach ($this->getStoredAqlArray() as $table) {
				if ($i == 0) {
					$this->_primary_table = $table['table'];
					$this->addProperty($this->_primary_table.'_id');
				}
				$this->tableMakeProperties($table);
				$i++;
			}
			unset($i);
		} else {
			if (!is_ajax_request()) {
				throw new Exception('AQL Error: <strong>'.$this->_model_name.'</strong> is not a valid model.');
				return;
			} else {
				exit_json(array(
					'status' => 'Error',
					'errors' => array(
						'AQL Error: <strong>'.$this->_model_name.'</strong> is not a valid model.'
					)
				));
			}
		}
		return $this;
	}

	/**
	 *	@param string $offset
	 */
	public function offsetExists($offset) {
		return isset($this->_data[$offset]);
	}

	/**
	 *	@param string $offset
	 */
	public function offsetGet($offset) {
		return (isset($this->_data[$offset])) ? $this->_data[$offset] : null;
	}

	/**
	 *	@param string $offset
	 *	@param value $value
	 */
	public function offsetSet($offset, $value) {
		if (is_array($value)) $value = self::toArrayObject($value);
		$this->$offset = $value;
	}

	/**
	 *	@param string $offset
	 */
	public function offsetUnset($offset) {
		unset($this->_data[$offset]);
	}

	/**
	 *	@param array $save_array 	gets passed in after save
	 *	@global $model_dependencies
	 */
	public function reload($save_array = null) {
		global $model_dependencies;
			
		$t = $this->getPrimaryTable();
		$id = $save_array[$t]['id'] ?: $this->_id;
		$this->_id = ($id) ?: $this->getID();

		if ($this->_id) {
			$this->loadDB($this->_id, true, true);
			if ($t) {
				if (is_array($model_dependencies[$t])) {
					foreach ($model_dependencies[$t] as $m) {
						if ($m == $this->_model_name) continue;
						Model::get($m, $this->_id, true);
					}
				}
			}
		}

		$this->construct();

	}

	/**
	 *	for when using memcache, if there are subobjects, re-fetch them from cache
	 *	to make sure they are up to date
	 *	@param Boolean $use_dbw		use master DB
	 */
	public function reloadSubs($use_dbw = false) {
		if (!$this->_refresh_sub_models) return;
		foreach (array_keys($this->_objects) as $o) {
			if ($this->_objects[$o] === 'plural') {
				foreach ($this->_data[$o] as $k) {
					if (self::isModelClass($k)) {
						$k->_force_db = false;
						$k->loadDB($k->_id, $this->_force_db, $use_dbw);
						$k->construct();
					}
				}
			} else if (self::isModelClass($this->_data[$o])) {
				$this->$o->_force_db = false;
				$this->$o->loadDB($this->$o->_id, $this->_force_db, $use_dbw);
				$this->$o->construct();
			}
		}
	}	

	/**
	 *	disables refresh_sub_models
	 */
	public function disableSubReload() {
		$this->_refresh_sub_models = false;
	}

	/**
	 *	@param string 	as many as needed, unsets the keys from _properties
	 *	@return Model 	$this
	 */
	public function removeProperty() {
		$num_args = func_num_args();
		$args = func_get_args();
		for ($i = 0; $i < $num_args; $i++) {
			unset($this->_properties[$args[$i]]);
		}
		return $this;
	}

	/**
	 *	@param array $arr		associative array of values to save
	 *	@return array 			response array
	 *	@throws Exception
	 */
	public function saveProperties($arr = array()) {
		
		if (!$this->getID()) {
			throw new Exception('Model::saveProperties can only used on a model with an identifier.');
		}

		if (!$arr || !is_array($arr)) {
			throw new Exception('Model::saveProperties expects a non empty array as an argument.');
		}

        $class = get_called_class();
        
        $tmp = new $class;
        $tmp->{$this->getPrimaryTable() . '_ide'} = $this->getIDE();

        $arr['_token'] = $tmp->getToken();
        $re = $tmp->loadArray($arr)->save();
        
        if ($re['status'] == 'OK') {
        	foreach (array_keys($arr) as $k) {
        		$this->$k = $tmp->$k;
        	}
        }

        return $re;
    }

	/**
	 *	has hooks that take the save array as an argument
	 *		- before_insert, after_insert 
	 *		- before_update, after_update
	 *	
	 *	@param Boolean $inner 	if this is an inner save
	 *	@return array 			response array
	 *	@global $dbw
	 *	@global $db_platform
	 *	@global $aql_error_email
	 *	@global	$is_dev
	 */
	public function save($inner = false) {
		
		global $dbw, $db_platform, $aql_error_email, $is_dev;
		if (!$dbw) $this->_errors[] = self::E_READ_ONLY;
		
		if ($inner) {
			$this->_use_token_validation = false;
			$this->_is_inner_save = true;
		}

		$this->validate();

		$aql_arr = $this->getStoredAqlArray();
		if (!$aql_arr) {
			$this->_errors[] = 'Cannot save model without an aql statement.';
		}

		if ($this->_errors) {
			return $this->after_fail();
		} 

		$is_insert = $this->isInsert();
		$is_update = $this->isUpdate();

		if ($is_insert && $this->methodExists('before_insert')) {
			$this->before_insert();
		}

		if ($is_update && $this->methodExists('before_update')) {
			$this->before_update();
		}

		$save_array = $this->makeSaveArray($this->_data, $aql_arr);

		if (!$save_array) {
			if (!$this->_is_inner_save) {
				$this->_errors[] = 'Error generating save array based on the model. There may be no data set.';
				return $this->after_fail();
			} else {
				return;
			} 
		}

		$save_array = $this->removeIgnores($save_array);

		if (!$this->_errors) {

			if ($this->_abort_save) {
				return $this->after_save($save_array);
			}

			if (!$this->_is_inner_save) {
				$dbw->startTrans();
			}
			
			if ($this->methodExists('before_save')) {
				$save_array = $this->before_save($save_array);
			}

			$save_array = $this->saveArray($save_array);
			$transaction_failed = $dbw->HasFailedTrans();

			if (!$this->is_inner_save) {
				$dbw->CompleteTrans();	
			}

			if ($transaction_failed) {
				return $this->_handleSaveFailure($save_array);
			} else {
				return $this->_handleSaveSuccess($save_array, $is_insert, $is_update);
			}

		}
		
	}

	/**
	 *	@param array $save_array
	 *	@return array
	 *	@global $is_dev
	 */
	protected function _handleSaveFailure($save_array) {
		global $is_dev;
		
		if (!in_array('Save Failed.', $this->_errors)) {
			$this->_errors[] = 'Save Failed.';
			if ($is_dev) {
				$this->_errors[] = 'Failure in model: ' . $this->_model_name;
				$this->_errors = array_merge($this->_errors, aql::$errors);
			}
		}

		return $this->after_fail($save_array);

	}

	/**
	 *	@param array $save_array
	 *	@param Boolean $is_insert
	 *	@param Boolean $is_update
	 *	@return array 
	 */
	protected function _handleSaveSuccess($save_array, $is_insert = false, $is_update = false) {
		
		if ($this->methodExists('before_reload')) {
			$this->before_reload();
		}

		$this->reload($save_array);

		if ($is_insert) {
			$this->refreshBelongsTo();
			if ($this->methodExists('after_insert')) $this->after_insert();
		}

		if ($is_update) {
			if ($this->methodExists('after_update')) $this->after_update();
		}

		return $this->after_save($save_array);

	}

	/**
	 * 	internval function triggered before after_insert and after_delete,
	 *	if belongs_to is defiend, it refreshes the objects defined by the array
	 *	
	 *	model_name => constructor_field
	 *	
	 *	IE: if this model is artist_album, which has artist_id
	 *		
	 *		public $_belongs_to = array(
	 *			'artist' => 'artist_id'
	 *		);
	 *
 	 *	@return Model 	$this
	 */
	protected function refreshBelongsTo() {
		
		if (!$this->_belongs_to || !is_assoc($this->_belongs_to)) {
			return $this;
		}

		foreach ($this->_belongs_to as $model => $field) {
			if (!$this->{$field}) continue;
			$model::refreshCache($this->{$field});
		}

		return $this;
	}
	
	/**
	 *	aql::insert/update on the save array depending on what needs to be done
	 * 	recursive because of sub objects / queries
	 *	@param array $save_array	array to save
	 *	@param array $ids			ids to pass through
	 *	@return array 				updated save array
	 *	@global $is_dev
	 */
	public function saveArray($save_array, $ids = array()) {
		global $is_dev;
		$objects = $save_array['__objects__'];
		unset($save_array['__objects__']);
		foreach ($save_array as $table => $info) {
			foreach ($ids as $n => $v) {
				if (is_array($this->_ignore['fields']) && in_array($n, $this->_ignore['fields'])) continue;
				if (is_array($info['fields']) && !$info['fields'][$n]) {
					$save_array[$table]['fields'][$n] = $v;
					$info['fields'][$n] = $v;
				}
			}
			if (is_numeric($info['id'])) {
				if (is_array($info['fields']) && $info['fields']) {
					if (!$info['fields']['update_time']) $info['fields']['update_time'] = aql::now();
					if (defined('PERSON_ID')) {
						if (!$info['fields']['mod__person_id']) $info['fields']['mod__person_id'] = PERSON_ID;
						if (!$info['fields']['update__person_id']) $info['fields']['update__person_id'] = PERSON_ID;
					}
					aql::update($table, $info['fields'], $info['id'], true);
				}
			} else {
				if (is_array($info['fields']) && $info['fields']) {
					$rs = aql::insert($table, $info['fields'], true);
					if (defined('PERSON_ID') && !$info['fields']['insert__person_id']) $info['fields']['insert__person_id'] = PERSON_ID;
					$save_array[$table]['id'] = $info['id'] = $rs[0][$table.'_id'];
				}
			}
			$ids[$table.'_id'] = $info['id'];
			if (is_array($info['subs'])) foreach ($info['subs'] as $i=>$sub) {
				$save_array[$table]['subs'][$i] = $this->saveArray($sub, $ids);
			}
		}
		if (is_array($objects)) foreach ($objects as $o) {
			if ($o['data']) {
				$tmp = Model::get($o['object']);
				$tmp->_data = $o['data'];
				$tmp->loadIDs($ids);
				$pt = $tmp->_primary_table;
				$pt_id = $pt.'_id';
				if (!$tmp->{$pt_id} && $this->$pt_id) {
					$tmp->$pt_id = $this->$pt_id;
				}
				$return = $tmp->save(true);
				if ($return['status'] != 'OK') {
					if (is_array($return['errors']))
						$this->_errors = $this->_errors + $return['errors'];
					// $this->_errors[] = "Error on Model: '{$o['object']}'";
					$this->failTransaction();
				}
			}
		}
		$save_array['objects'] = $objects;
		return $save_array;
	}

	/**
	 *	adds the properties of every the aliases in the aqlarray (table block)
	 *	@param string $table
	 *	@param mixed $sub
	 */
	public function tableMakeProperties($table, $sub = null) {
		if (is_array($table['objects'])) foreach ($table['objects'] as $k => $v) {
			$this->addProperty($k)->$k = array();
			$this->_objects[$k] = ($v['plural']) ? 'plural' : true;
		}

		if (is_array($table['fields'])) foreach ($table['fields'] as $k => $v) {
			if (preg_match('/[\b_]id$/', $k)) $this->addProperty($k.'e');
			$this->addProperty($k);
		}

		if (is_array($table['subqueries'])) foreach($table['subqueries'] as $k => $v) {
			$this->addProperty($k)->$k = array();
		}

		$this->addProperty($table['table'].'_id');
	}

	/**
	 *	transforms modelArrayObject to an array recursively
	 *	@param ModelArrayObject $obj
	 *	@return array
	 */
	public function toArray($obj) {
		if (is_object($obj) && get_class($obj) == 'ModelArrayObject') 
			$obj = $obj->getArrayCopy();

		if (is_array($obj)) foreach ($obj as $k => $v) {
			$obj[$k] = self::toArray($v);
		}
		return $obj;
	}

	/**
	 *	transforms array to arrayobject recursively
	 *	@param array $arr
	 *	@return ModelArrayObject
	 */
	public function toArrayObject($arr = array()) {
		$arr = new ModelArrayObject($arr);
		foreach ($arr as $k => $v) {
			$arr[$k] = (is_array($v)) ? self::toArrayObject($v) : $v;
		}
		return $arr;
	}

	/**
	 *	@return Model 		$this
	 */
	public function validate() {
		
		# run preValidation if the method is defined
		# validation does not continue if there are errors
		if ($this->methodExists('preValidate')) $this->preValidate();
		if ($this->_errors) return $this;

		$is_update = $this->isUpdate();
		$is_insert = $this->isInsert();

		# check if this is a valid token
		if ($is_update && $this->_use_token_validation) {		
			$token = $this->getToken();
			if ($token != $this->_token || !$this->_token) {
				$this->_return['token'] = $this->_token;
				$this->_errors[] = 'You do not have permission to update this record.';
				return $this;
			}
		}

		# check required fields
		foreach ($this->getRequiredFields() as $field) {
			if (!$this->fieldIsSet($field) && $is_update) continue;
			$name = ($this->_required_fields[$field]) ?: $field;
			$this->requiredField($name, $this->{$field});
		}

		# exit validation if there are errors
		if ($this->_errors) return $this;

		# check field specific validation (only if the field was set)
		foreach ($this->getProperties() as $prop) {
			if (!$this->fieldIsSet($prop)) continue;
			if (!$this->fieldHasValidation($prop)) continue;
			$this->{'set_' . $prop}($this->{$prop});
		}

		# exit validation if there are errors
		if ($this->_errors) return $this;

		# execute post validate
		if ($this->methodExists('postValidate')) $this->postValidate();

		return $this;

	}

	public function printData() {
		print_pre($this->_data);
	}

	public function printErrors() {
		print_pre($this->_errors);
	}
	
	/**
	 *	@param string $p
	 *	@return Boolean
	 */
	public function propertyExists($p) {
		return array_key_exists($p, $this->_properties);
	}

	/**
	 *	@param array $arr
	 * 	@return string 	JSON
	 */
	public static function returnJSON($arr = array()) {
		return json_encode($arr);
	}

	/**
	 *	@return array
	 */
	public function returnDataArray() {
		return $this->_data;
	}
	
	/**
	 *	If data is not set/null, add this to errors array
	 *	@param string $name
	 *	@param mixed $val
	 */
	public function requiredField($name, $val) {
		if (!is_null($val) && $val !== '') return; 
		$this->_errors[] = sprintf(self::E_FIELD_IS_REQUIRED, $name);
	}

	/**
	 *	@param string $field_name
	 *	@return Boolean
	 */
	public function fieldIsRequired($field_name) {
		return array_key_exists($field_name, $this->_required_fields);
	}

	/**
	 *	@param string $field_name
	 *	@return Boolean
	 */
	public function fieldIsSet($field_name) {
		return array_key_exists($field_name, $this->_data);
	}

	/**
	 *	@param string $field_name
	 *	@return Boolean
	 */
	public function fieldHasValidation($field_name) {
		return $this->methodExists('set_' . $field_name);
	}

	/**
	 *	@return Boolean
	 */
	public function isInsert() {
		return (!$this->{$this->_primary_table.'_id'});
	}

	/**
	 *	@return Boolean
	 */
	public function isUpdate() {
		return (!$this->isInsert());
	}

	/**
	 *	@param string $val
	 */
	public function validEmail($val) {
		$val = trim($val);
		if (!filter_var($val, FILTER_VALIDATE_EMAIL)) {
			$this->_errors[] = "{$val} is not a valid email address.";
		}
	}

	/**
	 *	@return Boolean
	 */
	public function isStaticCall() {
		if (!isset($this) && !self::isModelClass($this)) return true;
		$bt = debug_backtrace();
		return (!is_a($this, $bt[1]['class']));
	}

	/**
	 *	@param array $sets	associative
	 *	@return Model 		$this
	 */
	private function setConfig($sets = array()) {
		if (!$sets) return $this;
		$re = new ReflectionClass($this);
		$props = $re->getProperties(ReflectionProperty::IS_PROTECTED);
		foreach ($props as $prop) {
			$prop_name = $prop->getName();
			$key = substr($prop_name, 1);
			if (!array_key_exists($key, $sets)) continue;
			$this->{$prop_name} = $sets[$key];
			unset($sets[$key]);
		}
		return $this;
	} 

}