<?php

/**
 * Data modeling and CRUD handler
 * see: http://switchbreak.com/skyphp/classes/model
 * @package SkyPHP
 */
class Model implements ArrayAccess
{

    /**
     * static storage of aql statements and arrays, linked to aql2array storage
     * @var array
     */
    public static $_metadata = array();

    /**
     * Array of possible errors for the current model.
     *     'my_error_code' => [
     *         'message'   => 'The value for this field is invalid',
     *         'fields'    => ['my_field'] // optional
     *         'type'      => 'invalid'    // optional
     *    ]
     * You may also specify arbitray key value pairs that are helpful in each error
     * for your model
     * @var array
     */
    protected static $possible_errors = array();

    /**
     * Array of possible internal errors
     * Same format as possible errors
     * @var array
     */
    private static $internal_errors = array(
        'read_only' => array(
            'type' => 'fatal',
            'message' => 'The site is currently in "read only" mode. Changes have not been saved. Try again later.'
        ),
        'no_model_aql_statement' => array(
            'type' => 'fatal',
            'message' => 'Cannot save a model without an AQL statement.'
        ),
        'no_save_array' => array(
            'type' => 'fatal',
            'message' => 'Error generating save array based on the model. There may be no data set.'
        ),
        'model_save_failure' => array(
            'message' => 'Save Failed.',
            'type' => 'fatal'
        ),
        'rollback_triggered' => array(
            'message' => 'Save successful, but rollback triggered.'
        ),
        'invalid_token' => array(
            'fields' => array('_token'),
            'message' => 'You do not have permission to modify this record.',
            'type' => 'required'
        ),
        'field_is_required' => array(
            'type' => 'required'
        ),
        'identifier_not_set_for_delete' => array(
            'message' => 'Identifier is not set, there is nothing to delete.'
        ),
        'generic_validation_error' => array(
            'type' => 'invalid'
        ),
        'no_data_found' => array(
            'type' => 'fatal',
            'message' => 'No data found for this ID.'
        ),
        'invalid_json' => array(
            'type' => 'fatal',
            'message' => 'Error Loading JSON. JSON was not valid.'
        ),
        'aql_class_error' => array(
            'type' => 'fatal',
            'message' => 'Internal DB Error'
        ),
        'fatal_error' => array(
            // used in tryCallable()
        )
    );

    /**
     * Prefix used for validation methods (field specific)
     * Example: If you have a field in the aql called 'name'
     * Defining:
     *      function validate_name($value) {
     *          // check the value here
     *      }
     * Will make sure that method gets run automatically during runValidation()
     * @see Model::runValidation()
     * @see Model::checkValidateFields()
     * @see Model::getFieldsWithValidateMethods()
     * @see Model::fieldHasValidation()
     * @var string
     */
    public static $validation_prefix = 'validate_';

    /**
     * @var string
     */
    const E_NO_METHOD_EXISTS = 'Cannot call a method that does not exist.';

    /**
     * @var string
     */
    const E_METHOD_NOT_CALLABLE = 'This method is not callable.';

    /**
     * @var string
     */
    const E_INVALID_MODEL = 'AQL Error: <strong>%s</strong> is not a valid model.';

    /**
     * @var string
     */
    const E_METHOD_ALREADY_DEFINED = 'Method [%s] is already defined in this model.';

    /**
     * @var string
     */
    const E_FIELD_IS_REQUIRED = '%s is required.';

    /**
     * @var string
     */
    const E_FIELD_IS_INVALID = '%s is invalid.';

    /**
     * @var string
     */
    const E_NO_VALIDATION_CLASS = 'Cannot use this validation features without the Validation class.';

    /**
     * if true, the save will return after_save() without saving.
     * @var Boolean
     */
    public $_abort_save = false;

    /**
     * If true, the save will run through, but the transaction will be rolled back
     * @var Boolean
     */
    public $_rollback_save = false;

    /**
     * store actual .aql file when found or input aql
     * @var string
     */
    public $_aql = null;

    /**
     * generated by $this->_aql
     * this is only set if $this->_aql is set
     * @var array
     */
    public $_aql_array = array();

    /**
     * associative array of array('model_name' => 'constructor_field')
     * @see Model::refreshBelongsTo()
     * @var array
     */
    public $_belongs_to = array();

    /**
     * used to compare with static::$mod_time to see if the model is outdated
     * @var string
     */
    public $_cached_time = null;

    /**
     * stored data, corresponds to $this->_properties
     * @var array
     */
    public $_data = array();

    /**
     * array of errors, if it is non empty save()/delete() will return errorResponse()
     * @var array
     */
    public $_errors = array();

    /**
     * If true, loadDB() will always bypass cache
     * @var Boolean
     */
    public $_force_db = false;

    /**
     * Identifier set during loadDB() and reload()
     * @var int
     */
    public $_id;

    /**
     * settings used to ignore these fields on save
     * keys of arrays: tables (for joins), models (plural/singular by alias), subs
     * @var array
     */
    public $_ignore = array();

    /**
     * names of objects
     * @var array
     */
    public $_objects = array();

    /**
     * method storage used in addMethod()
     * @var array
     */
    public $_methods = array();

    /**
     * set by class name (if is a subclass)
     * @see Model::getModelDependencies()
     * @var string
     */
    public $_model_name = null;

    /**
     * primary table of the model
     * @var string
     */
    public $_primary_table = null;

    /**
     * array of properties allowed to be set, generated by the model's aql statement
     * @var array
     */
    public $_properties = array();

    /**
     * associative array of required fields array('field' => 'Display Name')
     * @var array
     */
    public $_required_fields = array();

    /**
     * key value pairs added to/ merged with this array
     * will be returned in response arrays (merged)
     * @var array
     */
    public $_return = array();

    /**
     * used to authorize updates
     * @var string
     */
    public $_token = null;

    ## these are configuration properties
    ## that can be set in the model __construct method $config param

    /**
     * if true, there will be no caching because this model has no name
     * @var Boolean
     */
    protected $_aql_set_in_constructor = false;

    /**
     * If false, $model->_token is not required for save/delete
     * @var Boolean
     */
    protected $_use_token_validation = false;

    /**
     * If false, sub objects caches will not be automatically refetched
     * @var Boolean
     */
    protected $_refresh_sub_models = true;

    /**
     * used for saving sub models (not requiring token validation for inner saves)
     * @var Boolean
     */
    protected $_is_inner_save = false;

    /**
     * Used to store if currently in saving or deleting state
     * If an attempt is made to call save() or delete() inside save() or delete()
     * There will be an error message added and this transaction will be aborted.
     *
     * Note:
     *  - This is private because it should never be used outside of this implementation,
     *    the base Model class
     *  - It does not only signify that we are in a Database Transaction,
     *    it means that the current INSTANCE is
     *  - To see if in a DB transaction use $this->inTransaction()
     *
     * @see self::delete()
     * @see self::save()
     * @var Boolean
     */
    private $_in_transaction = false;

    /**
     * Model constructor accepts arguments in a variety of ways:
     *
     * $o = new artist($data);
     * $o = new artist($id);
     * $o = new artist($id, $conf);             maps to new artist($id, null, false, $conf);
     * $o = new artist($id, true);              maps to new artist($id, null, true);
     * $o = new artist($id, true, $conf);       maps to new artist($id, null, true, $conf);
     * $o = new Model($id, $artist_aql, $conf); maps to new Model($id, $artist_aql, false, $conf);
     *
     * @param mixed $data      identifier
     *                         id, ide triggers loadDB()
     *                         array/object triggers loadArray()
     * @param mixed $aql       set aql for this model (if this is not a subclass)
     * @param mixed $force_db  if true we're loading from DB and writing to cache
     * @param array $config    configuration options
     *
     */
    final public function __construct($data = null, $aql = null, $force_db = false, $cnf = array())
    {
        # map arguments to correct vars
        list($aql, $force_db, $cnf) = $this->mapConstructArgs($aql, $force_db, $cnf);

        # initialize this model
        $this->_model_name = get_class($this);
        $this->getModelAql($aql)->makeProperties();

        # set if we're refreshing it
        $this->_force_db = ($force_db || $_GET['refresh']);

        # set configuration options for
        $this->setConfig($cnf);

        # load from DB if $id is set proper & run construct hook,
        # otherwise throw Exception
        $this->checkConstructorData($data, $force_db);
    }


    /**
     * checks for a proper identifier, loads object if set runs construct()
     * @param  mixed   $data               ID/IDE/stdClass/array
     * @param  Boolean $force_db           force db read (only valid if $data is id/ide)
     * @throws InvalidArgumentException    if invalid constructor type
     */
    final protected function checkConstructorData($data = null, $force_db = false)
    {
        if (!$data) {
            $this->construct();

            return;
        }

        # handle if we're loading
        if (is_string($data) || is_numeric($data)) {
            $this->loadDB($data, $force_db);
            $this->_token = $this->getToken();
            $this->construct();

            return;
        }

        # if stdClass cast it to array
        $data = (is_object($data) && get_class($data) == 'stdClass')
            ? (array) $data
            : $data;

        # load array if it's an associative array
        if (is_assoc($data)) {
            $this->construct();
            $this->loadArray($data);

            return;
        }

        # if we got this far there is a problem
        $e = 'The model __construct method does not support %s as a first argument. '
           . 'Only: null|false|numeric|IDE|array|stdClass';
        throw new InvalidArgumentException(sprintf($e, gettype($id)));
    }


    /**
     * maps constructor arguments to a standard format by type
     * @param  mixed $aql
     * @param  mixed $force_db
     * @param  mixed $cnf
     * @return array
     */
    final protected function mapConstructArgs($aql = null, $force_db = false, $cnf = array())
    {
        if (is_array($force_db)) {
            $cnf = $force_db;
            $force_db = false;
        }

        if (is_array($aql)) {
            $cnf = $aql;
            $aql = null;
        } elseif (is_bool($aql)) {
            $force_db = $aql;
            $aql = null;
        }

        # return fixed and uniform arguments

        return array($aql, $force_db, $cnf);
    }

    /**
     * so as to not use $this->methodExists() in constructor
     * @return Model $this
     */
    public function construct()
    {
        return $this;
    }

    /**
     * magic __call method
     * @param  string  $method
     * @param  array   $params
     * @return mixed
     * @throws Exception   if invalid method
     */
    public function __call($method, $params)
    {
        if (!$this->methodExists($method)) {
            throw new Exception(self::E_NO_METHOD_EXISTS);
        }

        if (!is_callable($this->_methods[$method])) {
            throw new Exception(self::E_METHOD_NOT_CALLABLE);
        }

        return call_user_func_array($this->_methods[$method], $params);
    }

    /**
     * if this model is called as a function, return dataToArray();
     *     ex: $o = new artist;
     *         $o(); # equivalent to $o->dataToArray();
     * @return array
     */
    public function __invoke()
    {
        return $this->dataToArray();
    }


    /**
     * Maps uses _getField as a magic getter if property exists
     * @param string $name
     * @return mixed
     */
    final public function __get($name)
    {
        return ($this->propertyExists($name))
            ? $this->_getField($name)
            : null;
    }

    /**
     * @param string $name
     * @return mixed
     */
    protected function _getField($name)
    {
        return $this->_data[$name];
    }

    /**
     * Magic Setter -- sets values to $this->_data
     * If $name looks like an ide, the ID version is set
     * Adds to errors if setting an invalid property
     *
     * @param string $name
     * @param mixed $value
     * @return Model $this
     */
    public function __set($name, $value)
    {
        // check to see if this is a valid property or IDE
        $is_ide = preg_match('/_ide$/', $name);

        // if this is property does not exist we add it as a property to the object
        if (!$this->propertyExists($name)) {
            $this->addProperty($name);
        }

        // cast to array or to ModelArrayObject as necessary
        $value = $this->prepSetValue($value);

        $this->_data[$name] = $value;

        // if is IDE, add as an ID as well
        if ($is_ide) {
            $key = aql::get_decrypt_key($name); // decrypt ide
            $n_name = substr($name, 0, -1);     // remove e (from ide)
            $this->_data[$n_name] = decrypt($value, $key);
        }

        return $this;
    }

    /**
     * Cast value to array if it is a stdClass
     * to arrayobject if it is an array otherwise return it as it was
     * @param  mixed $val
     * @return mixed
     */
    private function prepSetValue($val)
    {
        if (!is_array($val) && !is_object($val)) {
            return $val;
        }

        if (is_array($val)) {
            return self::toArrayObject($val);
        }
        if (get_class($val) == 'stdClass') {
            return (array) $val;
        }

        return $val;
    }

    /**
     * Casting a Model to a string returns $this->getID()
     * @return string
     */
    public function __toString()
    {
        return (string) $this->getID();
    }

    /**
     * This will trigger aborting of $this->save();
     * Validation still happens, and response is returned (after_fail or after_save)
     * @return Model $this
     */
    public function abortSave()
    {
        $this->_abort_save = true;
        return $this;
    }

    /**
     * This will trigger rolling back of the transaction and add an error
     * @return Model $this
     */
    public function rollbackSave()
    {
        $this->_rollback_save = true;
        return $this;
    }

    /**
     * merge to the required fields array
     * @param  array $arr                  associative array
     * @return Model $this
     * @throws InvalidArgumentException    $arr not associative
     */
    public function addRequiredFields($arr = array())
    {
        if (!is_assoc($arr)) {
            $e = 'Model::addRequiredFields expects an associative array '
               . 'with field => return name as a structure.';
            throw new InvalidArgumentException($e);
        }

        $this->_required_fields = array_merge($this->_required_fields, $arr);

        return $this;
    }

    /**
     * add any number of properties to the object
     * @param string   (any number of arguments)
     * @return Model $this
     */
    public function addProperty()
    {
        $num_args = func_num_args();
        $args = func_get_args();
        for ($i = 0; $i < $num_args; $i++) {
            $this->_properties[$args[$i]] = true;
        }

        return $this;
    }


    /**
     * alias for Model::addProperty()
     * @return Model $this
     */
    public function addProperties()
    {
        $args = func_get_args();
        call_user_func_array(array($this, 'addProperty'), $args);

        return $this;
    }

    /**
     * add a method to this model
     *     usage:
     *         $model->addMethod('testing', function($arg) use ($model) {
     *             // body
     *         });
     *         $model->testing($somearg);
     * @param  string      $name
     * @param  callback    $fn
     * @return Model       $this
     * @throws Exception   method is already defined
     */
    public function addMethod($name, $fn)
    {
        if ($this->methodExists($name)) {
            throw new Exception(sprintf(self::E_METHOD_ALREADY_DEFINED, $name));
        }

        $this->_methods[$name] = $fn;

        return $this;
    }

    /**
     * Calls a method with the given arguments if it exists
     * @param  string  $method
     * @param  mixed   arguments to pass to this methdo
     * @return mixed
     */
    public function callIfExists($method /* ,... */)
    {
        if (!$this->methodExists($method)) {
            return null;
        }
        $args = func_get_args();
        $args = array_slice($args, 1);

        return call_user_func_array(array($this, $method), $args);
    }

    /**
     * @param  string $name
     * @return Boolean
     */
    public function methodExists($name)
    {
        return (method_exists($this, $name))
            ?: array_key_exists($name, $this->_methods);
    }

    /**
     * Plural subobject specific "array_map", because these are not arrays
     * if the model has [sub_model]s
     *     $things = $model->mapSubObjects('sub_model', $callback)
     * @param  string      $name           object name
     * @param  callback    $fn             defaults to null
     * @param  Boolean     $skip_id_filter skip is filter, defaults to false
     * @return array                       like in array map
     * @throws InvalidArgumentException    invalid $name
     */
    public function mapSubObjects($name, $fn = null, $skip_id_filter = false)
    {
        if (!$this->isPluralObject($name)) {
            $e = 'mapSubObjects expects a valid plural object param.';
            throw new InvalidArgumentException($e);
        }

        if ($fn && !is_callable($fn)) {
            $e = '$fn is not callable.';
            throw new InvalidArgumentException($e);
        }

        $map = function($o) use ($skip_id_filter, $fn) {
            if (!$skip_id_filter && !$o->getID()) {
                return null;
            }

            return ($fn) ? $fn($o) : $o;
        };

        return array_map($map, (array) $this->{$name});
    }

    /**
     * @return array
     */
    protected function getErrorMessages()
    {
        return array_map(function($e) {
            return (is_string($e)) ? $e : $e->message;
        }, $this->_errors);
    }

    /**
     * @return array       response array
     * @final
     */
    final public function errorResponse()
    {

        if ($this->isDev()) {
            $this->_return['errors_verbose'] = $this->_errors;
        }

        return array_merge(array(
            'status' => 'Error',
            'errors' => array_filter($this->getErrorMessages()),
            'data' => $this->dataToArray(true)
        ), $this->_return);
    }

    /**
     * @return array       response array
     * @final
     */
    final public function successResponse()
    {
        return array_merge(array(
            'status' => 'OK',
            'data' => $this->dataToArray(true),
            '_token' => $this->getToken()
        ), $this->_return);
    }

    /**
     * @return Boolean
     */
    public function hasRequiredFields()
    {
        return (bool) (count($this->getRequiredFields() > 0));
    }

    /**
     * @return array
     */
    public function getRequiredFields()
    {
        return array_keys($this->_required_fields);
    }

    /**
     * @return int | null
     */
    public function getID()
    {
        $field = $this->getPrimaryTable() . '_id';
        $field_ide = $field . 'e' ;

        return $this->{$field} = ($this->{$field})
            ?: (($this->{$field_ide})
                ? decrypt($this->{$field_ide}, $this->_primary_table)
                : null);
    }

    /**
     * @return string | null
     */
    public function getIDE()
    {
        $field = $this->getPrimaryTable() . '_id';
        $field_ide = $field . 'e';

        return ($this->{$field_ide})
            ?: (($this->{$field})
                ? encrypt($this->{$field}, $this->_primary_table)
                : null);
    }

    /**
     * @return Boolean
     */
    public function hasID()
    {
        return (bool) $this->getID();
    }

    /**
     * Uses required fields to fetch the identifier of the object if it is not set
     * Should generally be used in postValidate() for a uniqueness constraint on the
     * required fields
     * This sets $this->{primary_table_id}
     *
     * @return Model   $this
     */
    public function getIDByRequiredFields()
    {
        # if there are errors | have ID | no required fields return
        if ($this->_errors || $this->getID() || !$this->hasRequiredFields()) {
            return $this;
        }

        # set up
        $where = array();
        $clause = array('limit' => 1, 'where' => &$where);
        $aql = sprintf('%s { }', $this->getPrimaryTable());
        $key = $this->getPrimaryTable() . '_id';

        # make where
        foreach ($this->getRequiredFields() as $f) {
            $where[] = sprintf("%s = '%s'", $f, $this->{$f});
        }

        $rs = aql::select($aql, $clause);
        $this->{$key} = ($rs[0][$key]) ?: $this->{$key};
        $this->_token = ($this->_token) ?: $this->getToken();

        return $this;
    }

    /**
     * Use to repopulate required fields from the database on save.
     * Only sets them if they are empty.
     * Must be called within a model. Best to use in preValidate(),
     * if the object must be unique.
     *
     * @param  int     $id     defaults to $this->getID(), exits if not present
     * @return Model   $this
     */
    public function preFetchRequiredFields($id = null)
    {
        $id = ($id) ?: $this->getID();
        if (!$id) {
            return $this;
        }

        $keys = $this->getRequiredFields();

        $continue = false;
        foreach ($keys as $f) {
            if (!$this->fieldIsSet($f)) {
                $continue = true;
                break;
            }
        }

        // return if all required fields are already set
        if (!$continue) {
            return $this;
        }

        // get data
        $r = aql::profile($this->getStoredAqlArray(), $id);
        if ($r) {
            foreach ($keys as $f) {
                if (!$this->fieldIsSet($f)) {
                    $this->_data[$f] = $r[$f];
                }
            }
        }

        return $this;
    }

    /**
     * returns $this->_data in array form
     * we use ModelArrayObjects instead of arrays and these need to get converted back
     *
     * @param  Boolean     $hide_ids   if true, remove "_id" fields (keep _ides)
     *                                 default false
     * @return array
     */
    public function dataToArray($hide_ids = false)
    {
        $return = array();
        $arr = ($arr) ?: $this->_data;
        foreach ($arr as $k => $v) {
            if ($this->_objects[$k] === 'plural') {
                foreach ($v as $i => $o) {
                    if (is_object($o) && self::isModelClass($o)) {
                        $return[$k][$i] = $o->dataToArray($hide_ids);
                    }
                }
            } elseif ($this->_objects[$k] && self::isModelClass($v)) {
                $return[$k] = $v->dataToArray($hide_ids);
            } elseif (is_object($v) && get_class($v) == 'ModelArrayObject') {
                $return[$k] = self::dataToArraySubQuery($v);
            } else {
                $is_id = (substr($k, -3) == '_id');
                if (!$is_id || !$hide_ids) {
                    $return[$k] = $v;
                }
            }
        }

        return $return;
    }

    /**
     * Helper for Model::dataToArray() for when this is a ModelArrayObject
     * @param  array   $arr
     * @param  Boolean $hide_ids
     * @return array
     */
    public function dataToArraySubQuery($arr = array(), $hide_ids = false)
    {
        $return = array();
        foreach ($arr as $k => $v) {
            if (is_object($v) && self::isModelClass($v)) {
                $return[$k] = $v->dataToArray($hide_ids);
            } elseif (is_object($v) && get_class($v) == 'ModelArrayObject') {
                $return[$k] = self::dataToArraySubQuery($v, $hide_ids);
            } else {
                if (is_object($v)) {
                    $v = (array) $v;
                }
                $is_id = (substr($k, -3) == '_id');
                if (!$is_id || !$hide_ids) {
                    $return[$k] = $v;
                }
            }
        }
        unset($arr);

        return $return;
    }


    /**
     * Deletes the current record if there is a token and identifier
     * by setting active = 0
     * and clears memcache
     *
     * Triggers events: before_delete and after_delete
     * Refreshes $this->_belongs_to
     *
     * @return array   the response array (after_fail or after_save)
     */
    public function delete()
    {
        if ($this->_in_transaction) {
            $this->addInternalError('fatal_error', array(
                'message' => 'Cannot delete current instance while in transaction.',
                'type' => 'invalid_action'
            ));

            return;
        }

        $id = $this->getID();

        if ($this->_use_token_validation &&
            ($this->_token != Model::generateToken($id, $this->_primary_table) ||
            !$this->_token)
        ) {
            $this->addInternalError('invalid_token');
        }

        if (!$id) {
            $this->addInternalError('identifier_not_set_for_delete');
        }

        if ($this->_errors) {
            return $this->errorResponse();
        }

        $this->_in_transaction = true;
        $this->startTransaction();

        $now = aql::now();
        $fields = array(
            'active' => 0,
            'mod_time' => $now,
            'update_time' => $now
        );

        if (defined('PERSON_ID') && PERSON_ID) {
            $fields['mod__person_id'] = $fields['update__person_id'] = PERSON_ID;
        }

        # load the object
        # so that we have the information left over for after_delete hooks
        $this->loadDB($id);

        if ($this->methodExists('beforeDelete')) {
            $this->tryCallable(array($this, 'beforeDelete'));
        }

        if ($this->hasFailedTransaction() || $this->_errors) {
            return $this->getTransactionResponse(true);
        }

        if (aql::update($this->_primary_table, $fields, $id)) {

            # clears the memcache of stored objects of this identifier.
            $delete_key = function($m) use ($id) {
                $tmp = new $m;
                $key = $tmp->getMemKey($id);
                \Sky\Memcache::delete($key);
            };

            $delete_key($this->_model_name);
            foreach ($this->getModelDependencies() as $m) {
                $delete_key($m);
            }

            if ($this->methodExists('afterDelete')) {
                $this->tryCallable(array($this, 'afterDelete'));
            }

            if ($this->hasFailedTransaction() || $this->_errors) {
                return $this->getTransactionResponse(true);
            }

            $this->refreshBelongsTo();

            $re = $this->getTransactionResponse();
            unset($re['data'], $re['_token']);

            return $re;

        } else {

            $this->addInternalError('model_save_failure', array(
                'message' => 'Error deleting record.'
            ));

            return $this->getTransactionResponse(true);
        }
    }

    /**
     * @param  string $ext         extension for file, default: php
     * @return string              path to form file with given extension
     * @global $sky_aql_model_path
     */
    public function getFormPath($ext = 'php')
    {
        global $sky_aql_model_path;
        $format = '%s%s/form.%s.%s';
        $with = array($sky_aql_model_path, $this->_model_name, $this->_model_name, $ext);

        return vsprintf($format, $with);
    }

    /**
     * Includes the form file (path/to/models/Model/form.Model.php) in $this scope
     * @return Model
     * @throws Exception       path not found
     */
    public function includeForm()
    {
        $path = $this->getFormPath();
        if (!file_exists_incpath($path)) {
            throw new Exception("Form file [{$path}] does not exist for this model");
        }
        $r = $o = $this;
        include $path;

        return $this;
    }

    /**
     * @return ADODB Connection | null
     */
    public function getMasterDB()
    {
        return aql::getMasterDB();
    }

    /**
     * Triggers DBW transaction failure
     * @return Model   $this
     */
    public function failTransaction()
    {
        $this->getMasterDB()->FailTrans();
        \Sky\Memcache::fail();
        return $this;
    }

    /**
     * @return Boolean
     */
    public function hasFailedTransaction()
    {
        return $this->getMasterDB()->HasFailedTrans();
    }

    /**
     * Starts db transaction
     * @return Model   $this
     */
    public function startTransaction()
    {
        if (!$this->inTransaction() && !$this->_is_inner_save) {
            $this->getMasterDB()->StartTrans();
            \Sky\Memcache::begin();
        }

        return $this;
    }

    /**
     * @return Boolean
     */
    public function inTransaction()
    {
        return $this->getMasterDB()->transOff;
    }

    /**
     * stops the transaction if we are not currently saving in a submodel
     * @param  Boolean $fail
     * @return Model   $this
     */
    public function stopTransaction($fail = false)
    {
        if ($fail) {
            $this->failTransaction();
        }

        if ($this->inTransaction() && !$this->_is_inner_save) {
            $this->getMasterDB()->CompleteTrans();
            \Sky\Memcache::end();
        }

        return $this;
    }

    /**
     * runs generic validation on the field given using Validation class in CMS.
     *
     * @param  string $field       name of the field
     * @param  string $name        display name of the field, used for errors
     * @param  string $val         value of the field
     * @param  string $fn          name of the method to use in validation class
     * @param  boolean $replace    if true, replace the value given with return of
     *                             ValidationMethod
     *
     * @throws Exception           Validation class doesnt exist
     */
    public function genericValidation($field, $name, $val, $fn, $replace = false)
    {
        if (!class_exists('validation')) {
            throw new Exception(self::E_NO_VALIDATION_CLASS);
        }

        # exit if we can't call this function
        if (!$field || !$name || !is_callable('validation', $fn) || !$val) {
            return;
        }

        $valid = validation::$fn($val);

        if (!$valid) {
            $this->addInternalError('generic_validation_error', array(
                'message' => sprintf(self::E_FIELD_IS_INVALID, $name)
            ));
        } elseif ($replace) {
            $this->_data[$field] = $valid;
        }
    }

    /**
     * @param  string $str             model name
     * @param  mixed $id               identifier (id, ide)
     * @param  Boolean $force_db       force_db read, defaults to false
     * @return Model
     *
     * @throws Exception               no model name
     * @throws LogicException          str is a class but a model
     */
    public static function get($str = null, $id = null, $force_db = false)
    {
        if (!is_string($str)) {
            throw new Exception('Model name or AQL must be specified when using Model::get()');
        }

        # get class if it exists
        aql::include_class_by_name($str);
        $exists = class_exists($str);

        if ($exists && !self::isModelClass($str)) {
            throw new LogicException(sprintf('Class [%s] exists, but is not a model.', $str));
        }

        return ($exists)
            ? new $str($id, null, $force_db)
            : new Model($id, $str);
    }

    /**
     * Returns an object based on the argument $o
     * @param  mixed   $o
     * @return Model
     * @throws ModelNotFoundException if cannot find the model
     */
    public static function convertToObject($o)
    {
        if (self::isModelClass($o)) {
            return $o;
        }

        $cl = get_called_class();
        $obj = new $cl($o);

        if (!$obj->getID()) {
            throw new ModelNotFoundException('Model object not found');
        }

        return $obj;
    }

    /**
     * Returns an ID based on the argument $o
     * @param  mixed   $o
     * @return string
     * @throws \Exception if cannot find the ID
     */
    public static function convertToID($o)
    {
        if (is_numeric($o)) {
            return $o;
        }

        if (self::isModelClass($o)) {
            $id = $o->getID();
            if (!$id) {
                throw new Exception('Paramter is an empty object');
            }

            return $id;
        }

        $cl = get_called_class();
        $tmp = new $cl;
        $tbl = $tmp->getPrimaryTable();

        $id = decrypt($o, $tbl);
        if (!$id) {
            throw new Exception('ID not found.');
        }

        return $id;
    }

    /**
     * Returns an IDE based on the argument $o
     * @param  mixed   $o
     * @return string
     * @throws \Exception if cannot find the IDE or it is invalid
     */
    public static function convertToIDE($o)
    {
        if (self::isModelClass($o)) {
            $ide = $o->getIDE();
            if (!$ide) {
                throw new Exception('Parameter is an empty object.');
            }

            return $ide;
        }

        $cl = get_called_class();
        $tmp = new $cl;
        $tbl = $tmp->getPrimaryTable();

        if (is_numeric($o)) {
            return encrypt($o, $tbl);
        }

        $id = decrypt($o, $tbl);
        if (!$id) {
            throw new Exception('IDE not found.');
        }

        return $o;
    }

    /**
     * Does not check the cache for the object,
     * reads directly from DB and writes to cache.
     * @param  mixed $id   identifier (id, ide)
     * @return Model
     * @throws Exception   if called on Model (not subclass)
     */
    public static function refreshCache($id)
    {
        $class = get_called_class();
        if ($class == 'Model') {
            throw new Exception('Model::refreshCache needs to be called on a subclass');
        }

        return new $class($id, null, true);
    }

    /**
     * example:
     *     if the model is:
     *         artist {
     *             ... fields
     *             [artist_album]s,
     *             [artist_genre]s,
     *             [artist_label]
     *         }
     *     php:
     *     $o = artist::getPartial($id, array(
     *         'artist_label' => true,
     *         'artist_album' => array(
     *             'artist_album_label' => true
     *         )
     *     ));
     * @param  mixed $id       identifier (id, ide)
     * @param  array $refresh  associative array of values to refresh
     *                         (multidimentional possibly)
     * @return Model
     */
    public static function getPartial($id = null, $refresh = array())
    {
        $cl = get_called_class();

        $o = new $cl($id, null, false, array(
            'refresh_sub_models' => false
        ));

        if (is_array($refresh)) {
            foreach ($refresh as $k => $v) {
                if (!$o->isObjectParam($k)) {
                    continue;
                }
                if ($o->isPluralObject($k)) {
                    foreach ($o->{$k} as $key => $sub) {
                        $class = get_class($sub);
                        $o->_data[$k][$key] = $class::getPartial($sub->getID(), $v);
                    }
                } else {
                    $class = get_class($o->$k);
                    $o->_data[$k] = $class::getPartial($o->$k->getID(), $v);
                }
            }
        }

        return $o;
    }

    /**
     * get the name of hte object if it has an alias
     * @param  string  $str    object alias
     * @return string
     */
    public function getActualObjectName($str)
    {
        if (!$this->isObjectParam($str)) {
            return '';
        }
        foreach ($this->getStoredAqlArray() as $table) {
            if ($table['objects'][$str]) {
                return $table['objects'][$str]['model'];
            }
        }

        return '';
    }

    /**
     * @return string      AQL statement of calling class
     */
    public static function getAQL()
    {
        $c = get_called_class();

        return self::_getAql($c);
    }

    /**
     * @return  string
     */
    public function getMinAQL()
    {
        return aql::get_min_aql_from_model($this->_model_name);
    }

    /**
     * sets model name based on aql, sets this as a tmp model (_aql_set_in_constructor)
     * @param string $aql      aql statemnt or empty
     * @return Model
     */
    public function getModelAql($aql = null)
    {
        if ($this->getStoredAql()) {
            return $this;
        }

        if (!$aql) {
            $this->_getAql($this->_model_name);
        } elseif (aql::is_aql($aql)) {
            $this->_aql = $aql;
            $this->_aql_set_in_constructor = true;
        } else {
            $this->_model_name = $aql;
            $this->_getAql($this->_model_name);
        }

        return $this;
    }

    /**
     * @return string      get model aql statement
     */
    public function getStoredAql()
    {
        return (aql2array::$aqls[$this->_model_name]) ?: $this->_aql;
    }

    /**
     * @return array       get model aqlarray (parsed aql)
     */
    public function getStoredAqlArray()
    {
        return (aql2array::$aqlArrays[$this->_model_name]) ?: $this->_aql_array;
    }

    /**
     * @param string $model_name       name of model
     * @return string                  aql statemnt
     */
    protected function _getAql($model_name)
    {
        return if_not(aql2array::$aqls[$model_name], function() use ($model_name) {
            return aql2array::$aqls[$model_name] = aql::get_aql($model_name);
        });
    }

    /**
     * returns an array of objects or one object if limit is set to 1
     * @param  array $clause        clause array
     * @param  string $model_name   model name, if null, using called class
     * @return mixed   if limit => 1, object or null, otherwise an array (can be empty)
     * @throws Exception
     */
    public static function getByClause(array $clause, $model_name = null)
    {
        $model_name = ($model_name) ?: self::getCalledClass();
        if (!$model_name || $model_name == 'Model') {
            throw new Exception('Model::getByClause expects a second parameter of model_name.');
        }

        $rs = array_map(function($r) use ($model_name) {
            return new $model_name($r);
        }, $model_name::getList($clause));

        return ($clause['limit'] === 1) ? $rs[0] : $rs;
    }

    /**
     * Return array of objects matching the criteria specified
     * @param  array $clause
     * @return array
     */
    public static function getMany(array $clause = array())
    {
        return static::getByClause($clause);
    }

    /**
     * Return a single object matching the criteria specified
     * @param  array $clause
     * @return Model | null
     */
    public static function getOne(array $clause = array())
    {
        return static::getByClause(array_merge($clause, array(
            'limit' => 1
        )));
    }

    /**
     * return the count of objects matching the criteria specified
     * @param array $clause
     * @return int
     */
    public static function count(array $clause = array())
    {
        return static::getList($clause, true);
    }

    /**
     * returns an array of ids
     * @param   array   $clause             clause array
     * @param   Boolean $do_count           if true, returns a count of the list
     * @return  array
     * @throws  \Exception                  if this is not a subclasss
     */
    public static function getList($clause = array(), $do_count = false)
    {
        $model_name = self::getCalledClass();
        if (!$model_name || $model_name == 'Model') {
            throw new Exception('Cannot use getList on a non subclass of Model.');
        }

        $fn = \getList::getFn(\aql::get_aql($model_name));

        return $fn($clause, $do_count);
    }

    /**
     * to be used on an instantiated object
     * @param mixed $id                identifier(id, ide), default: $this->getID()
     * @param string $primary_table    primary_table, default: $this->getPrimaryTable()
     * @return mixed                   string or null
     */
    public function getToken($id = null, $primary_table = null)
    {
        $primary_table = ($primary_table) ?: $this->getPrimaryTable();
        if ($id && !is_numeric($id)) {
            $id = decrypt($id, $primary_table);
        }
        $id = ($id) ?: $this->getID();

        return self::_makeToken($id, $primary_table);
    }

    /**
     * to be used statically
     * @param mixed $id                identifier (id, ide)
     * @param string $primary_table    primary_table, default to get called class
     * @return mixed                   string or null
     */
    public static function generateToken($id = null, $primary_table = null)
    {
        if (!$primary_table) {
            $cl = get_called_class();
            $o = new $cl;

            return $o->getToken($id);
        }

        if ($id && !is_numeric($id)) {
            $id = decrypt($id, $primary_table);
        }

        return self::_makeToken($id, $primary_table);
    }

    /**
     * @param int $id
     * @param string $table
     * @return mixed       string or null
     */
    private static function _makeToken($id, $table)
    {
        return ($id && $table)
            ? encrypt($id, encrypt($id, $table))
            : null;
    }

    /**
     * @return mixed       string or null (class name)
     */
    public function getCalledClass()
    {
        if (!self::isStaticCall()) {
            return get_class($this);
        }

        return (function_exists('get_called_class')) ? get_called_class() : null;
    }

    /**
     * @return array
     */
    public function getAqlArray()
    {
        return $this->getStoredAqlArray();
    }

    /**
     * returns model name or stored aql depending on if it is a temp model or not
     * @return string
     */
    public function getModel()
    {
        return $this->getStoredAql();
    }

    /**
     * returns model name or aql array depending on if its a temp model
     * @return mixed       array or string
     */
    public function getModelName()
    {
        return (get_class($this) == 'Model')
            ? $this->getStoredAqlArray()
            : $this->_model_name;
    }

    /**
     * @return string
     */
    public function getPrimaryTable()
    {
        return $this->_primary_table;
    }

    /**
     * @return array
     */
    public function getProperties()
    {
        return array_keys($this->_properties);
    }

    /**
     * @param  mixed $class
     * @return Boolean
     */
    public static function isModelClass($class)
    {
        if (!is_object($class) &&
            (is_numeric($class) || (is_string($class) && !trim($class)))
        ) {
            return false;
        }

        try {
            $ref = new ReflectionClass($class);

            return ($ref->isSubclassOf('Model') || $ref->name == 'Model');
        } catch (ReflectionException $e) {
            return false;
        }
    }

    /**
     * @param  string $str      property name
     * @return Boolean
     */
    public function isObjectParam($str)
    {
        return array_key_exists($str, $this->_objects);
    }

    /**
     * @param string $str      property name
     * @return Boolean
     */
    public function isPluralObject($str)
    {
        return ($this->isObjectParam($str))
            ? ($this->_objects[$str] === 'plural')
            : false;
    }

    /**
     * @param string $str      property name
     * @return Boolean
     */
    public function isSingleObject($str)
    {
        return ($this->isObjectParam($str) && !$this->isPluralObject($str));
    }

    /**
     * Properly loads an associative array of properties into the object
     * - decrypts ides
     * - creates objects
     * @param   array   $array
     * @return  Model   $this
     * @throws  \InvalidArgumentException if non associative array
     */
    public function loadArray($array = array())
    {
        $array = ($array) ?: $_POST;
        if (!$array) {
            return $this;
        }

        if (!\is_assoc($array)) {
            throw new \InvalidArgumentException('
                loadArray() expects an associative array argument'
            );
        }

        foreach ($array as $k => $v) {

            if ($this->isObjectParam($k)) {

                $obj = $this->getActualObjectName($k);
                \aql::include_class_by_name($obj);

                $loader = function($var) use($obj) {
                    if (!is_array($var)) {
                        return $var;
                    }

                    $tmp = (class_exists($obj)) ? new $obj : new Model(null, $obj);
                    return $tmp->loadArray($var);
                };

                $v = ($this->isPluralObject($k)) ? array_map($loader, $v) : $loader($v);
            }

            $this->{$k} = $v;
        }

        return $this;
    }

    /**
     * @param Model $o
     * @return Boolean
     */
    public static function cacheExpired($o)
    {
        $mod_time = (isset($o::$mod_time)) ? $o::$mod_time : null;

        if (!$mod_time) {
            return false;
        }
        if (!$o->_cached_time) {
            return true;
        }

        $is_expired = (bool) (strtotime($o->_cached_time) <= strtotime($mod_time));
        elapsed('cacheExpired:' . var_export($is_expired, true));

        return $is_expired;
    }

    /**
     * @param   mixed       $id    identifier(id, ide), default: $this->getID()
     * @return  string
     * @global  $db_name
     */
    public function getMemKey($id = null)
    {
        $id = ($id) ?: $this->getID();
        if (!$id) {
            return null;
        }

        $v = (isset($this::$mod_time))
            ? ':v' . strtotime($this::$mod_time)
            : null;

        global $db_name;
        $prefix = ($db_name) ? $db_name . ':' : '';

        return $prefix . $this->_model_name . ':loadDB' . $v . ':' . $id;
    }

    /**
     * checks to see if this is a valid identifier for this Model
     * Uses memcache first, then check DB
     * @param  string | int    $id     id or ide of the model
     * @return Boolean
     */
    public static function exists($id)
    {
        # memoize results to minimize requests to cache or db
        static $results = array();

        $cl = get_called_class();
        $o = new $cl;

        # make sure this is numeric or decryptable
        $table = $o->getPrimaryTable();
        $id = ($id && !is_numeric($id)) ? decrypt($id, $table) : $id;
        if (!$id || !$table) {
            return false;
        }

        $getSQL = function($table, $id) {
            $sql = 'SELECT id FROM %s WHERE id = %s AND active = 1';

            return sprintf($sql, $table, $id);
        };

        $key = $o->getMemKey($id);
        if (array_key_exists($key, $results)) {
            return $results[$key];
        }

        $found = (bool) mem($key);

        if (!$found) {
            # if we do not find it in memcache, check for the record in DB
            $sql = $getSQL($table, $id);
            $r = sql($sql);
            $found = (bool) ($r->Fields('id') == $id);
        }

        return $results[$key] = $found;
    }

    /**
     * Attempts to fetch data from cache, sets the object,
     * otherwise, reads from db, sets the object and cache
     *
     * @param  mixed $id                   identifier(id, ide)
     * @param  Boolean $force_db           force db read, default: false
     * @param  Boolean $use_dbw            force master db read, default: false
     * @return Model   $this
     * @throws InvalidArgumentException    invalid identifier
     * @throws ModelNotFoundException      when object not found
     * @throws LogicException              if cannot generate cache key
     */
    public function loadDB($id, $force_db = false, $use_dbw = false)
    {
        $id = (!is_numeric($id)) ? decrypt($id, $this->getPrimaryTable()) : $id;

        if (!$id) {
            throw new InvalidArgumentException('Invalid Identifier passed to loadDB()');
        }

        $mem_key = $this->getMemKey($id);
        if (!$mem_key) {
            throw new LogicException('Could not generate cache key.');
        }

        # exit early if load will fail
        if ($this->_errors) {
            return $this;
        }

        # set booleans
        $reload_subs = false;
        $force_db = ($force_db || $this->_force_db || $_GET['refresh']) ? true : false;
        $is_subclass = ($this->_model_name != 'Model');

        # if reloading from DB, make sure we're doing it form Master, not slave.
        if ($force_db || $use_dbw) {
            $use_dbw = true;
            $dbw = $this->getMasterDB();
        }
        $conn = ($use_dbw) ? $dbw : null;

        # for lexical binding with anonymous funcitons.
        $that = $this;

        # function that reads and sets data
        $load = function($mem_key = null) use ($that, $conn, $id) {
            $o = aql::profile($that->getModelName(), $id, true, $that->_aql, true, $conn);
            if ($mem_key) {
                $o->_cached_time = date('c');
                \Sky\Memcache::set($mem_key, $o);
            }
            return $o;
        };

        if (!$force_db && $is_subclass) {
            $o = mem($mem_key);         # do a normal get from cache
            if (!$o->_data || self::cacheExpired($o)) {
                $o = $load($mem_key);   # if cache not found or expired, load from DB
            } else {
                $reload_subs = true;    # we will be reloading submodels
            }
        } elseif ($force_db && $is_subclass && !$this->_aql_set_in_constructor) {
            $o = $load($mem_key);       # refresh was specified
        } else {
            $o = $load();               # this is a temp model, fetch from db
        }

        if (self::isModelClass($o) && is_array($o->_data)) {

            # we have a proper object fetched, update the data in $this using $o
            $arr = array('data', 'properties', 'objects');

            array_walk($arr, function($key) use ($o, $that) {
                $k = '_' . $key;
                $that->$k = array_merge($that->$k, $o->$k);
            });

            $this->_id = $id;
            $this->_cached_time = $o->_cached_time;

            if ($reload_subs) {
                $this->reloadSubs($use_dbw);
            }

        } else {
            # throw new ModelNotFoundException; # some time in the future
            $this->addInternalError('no_data_found');
        }

        return $this;
    }

    /**
     * Used during save to pass created ids down to subobjects if the property exists
     * @param array $ids       associative of id_field => value
     * @return Model           $this
     */
    public function loadIDs($ids = array())
    {
        foreach ($ids as $k => $v) {
            if (!$this->_data[$k] && $this->propertyExists($k)) {
                $this->_data[$k] = $v;
            }
        }

        return $this;
    }

    /**
     * @param string $json
     * @return Model $this
     */
    public function loadJSON($json)
    {
        $array = json_decode($json, true);
        if (is_array($array)) {
            $this->loadArray($array);
        } else {
            $this->addInternalError('invalid_json');
        }

        return $this;
    }

    /**
     * Caches the current state of the object
     */
    public function updateCache()
    {
        $this->_cached_time = date('c');
        \Sky\Memcache::set($this->getMemKey(), $this);
    }

    /**
     * Creates and stores the parsed AQL array
     */
    public function makeAqlArray()
    {
        $m = $this->_model_name;
        if ($m == 'Model' || !$m) {
            $this->_aql_array = aql2array($this->_aql);
        } else {
            self::$_metadata[$m]['aql_array'] = &aql2array::get($m, $this->getStoredAql());
        }
    }

    /**
     * makes a foreign key array from the aql array
     * used to figure out in what order saves will happen if there are joins
     * @param array $aql_array
     * @return array
     */
    public function makeFKArray($aql_array)
    {
        $fk = array();
        foreach ($aql_array as $k => $v) {
            if (is_array($v['fk'])) {
                foreach ($v['fk'] as $f) {
                    $fk[$f][] = $v['table'] ;
                }
            }
        }

        return $fk;
    }

    /**
     * Recursively construct an array with key (table name), value (fields, id)
     * to use in aql::insert() and aql::update()
     * sets __objects__ key for subobjects
     * sets subs for nested aql
     *
     * @param array $data_array        defaults to $this->_data
     * @param array $aql_array         defaults to $this->getStoredAqlArray()
     * @return array
     */
    public function makeSaveArray($data_array = array(), $aql_array = array())
    {
        # the set up (this method is recursive)
        if (!$data_array && !$aql_array) {
            $data_array = $this->_data;
            $aql_array = $this->getStoredAqlArray();
        }

        # initialize helpers
        $tmp = array();
        $addSubObject = function($o) use (&$tmp) {
            $tmp['__objects__'][] = array(
                'object' => get_class($o),
                'data' => $o->_data
            );
        };
        $is_IDE = function($field) {
            return (substr($field, '-4') == '_ide');
        };
        $is_ID = function($field) {
            return (substr($field, '-3') == '_id');
        };
        $isID = function($field) {
            return ($field == 'id');
        };
        $ideMatchesTable = function($ide, $table) {
            return (substr($k, 0, -4) == $table);
        };
        $prepName = function($str) {
            return substr($str, strpos($str, '.') + 1); # removes the table_name. prefix
        };

        if (is_array($data_array)) {

            foreach ($data_array as $k => $d) {

                if (!is_object($d) && !$this->isObjectParam($k)) {

                    # this aql level, tables/fields
                    foreach ($aql_array as $table => $info) {
                        $tname = $info['table'];
                        if ($info['fields'][$k]) {
                            $field_name = $prepName($info['fields'][$k]);
                            if ($isID($tmp[$tname]['fields'][$field_name])) {
                                $tmp[$tname]['id'] = $d;
                            } else {
                                $tmp[$tname]['fields'][$field_name] = $d;
                            }
                        } elseif ($is_IDE($k)) {
                            if ($ideMatchesTable($k, $tname)) {
                                $tmp[$tname]['id'] = decrypt($d, $tname);
                            }
                        } elseif ($is_ID($k)) {
                            $table_name = explode('__', substr($k, 0, -3));
                            $table_name = ($table_name[1]) ?: $table_name[0];
                            if ($tname == $table_name && $d !== null) {
                                $tmp[$tname]['id'] = $d;
                            }
                        }
                    }

                } elseif ($this->isObjectParam($k)) {

                    # sub objects of this model
                    if ($this->isPluralObject($k)) {
                        foreach ($d as $i => $obj) {
                            $addSubObject($obj);
                        }
                    } else {
                        $addSubObject($d);
                    }

                } else {

                    # this is a "subquery"
                    foreach ($aql_array as $table => $info) {

                        if (!is_array($info['subqueries'])) {
                            continue;
                        }

                        $tname = $info['table'];
                        foreach ($info['subqueries'] as $sub_k => $sub_v) {
                            if ($k != $sub_k) {
                                continue;
                            }
                            foreach ($d as $i => $s) {
                                $s = (is_object($s) && get_class($s) == 'stdClass')
                                    ? (array) $s
                                    : $s;
                                $tmp[$tname]['subs'][] = $this->makeSaveArray($s, $sub_v);
                            }
                            break;
                        }

                    }
                } # end if subquery

            } # end for each data

        } # end if array

        # make sure that the array is in the correct order

        return self::makeSaveArrayOrder($tmp, self::makeFKArray($aql_array));
    }

    /**
     * reorders the saveArray based on the foreign keys
     * @param  array $save_array        saveArray
     * @param  array $fk                foreign key array
     * @return array
     */
    public function makeSaveArrayOrder($save_array, $fk)
    {
        $return_array = array();    # array to return
        $first = array();           # prepends to return array
        foreach ($fk as $parent => $subs) {
            foreach ($subs as $dependent) {
                if ($save_array[$dependent]) {
                    if (!array_key_exists($dependent, $fk)) {
                        $return_array[$dependent] = $save_array[$dependent];
                        unset($save_array[$dependent]);
                    } else {
                        $return_array = array($dependent => $save_array[$dependent]) + $return_array;
                        unset($save_array[$dependent]);
                    }
                }
            }
        }

        return $save_array + $return_array;
    }

    /**
     * removes $this->_ignore props from the save array
     * @param  array $save_array    save array
     * @return array               filtered save array
     */
    public function removeIgnores($save_array = array())
    {
        if (!$this->_ignore) {
            return $save_array;
        }

        # remove tables
        if (is_array($this->_ignore['tables'])) {
            foreach ($this->_ignore['tables'] as $remove) {
                if (array_key_exists($remove, $save_array)) {
                    unset($save_array[$remove]);
                }
            }
        }

        # remove objects
        if (is_array($this->_ignore['objects']) && $save_array['__objects__']) {
            foreach ($this->_ignore['objects'] as $remove) {
                foreach ($save_array['__objects__'] as $k => $v) {
                    if ($v['object'] == $remove) {
                        unset($save_array['__objects__'][$k]);
                    }
                }
            }
        }

        # remove subs
        if (is_array($this->_ignore['subs'])) {
            foreach ($this->_ignore['subs'] as $remove) {
                foreach ($save_array as $i => $k) {
                    if (is_array($k['subs'])) {
                        foreach ($k['subs'] as $n => $sub) {
                            if (array_key_exists($remove, $sub)) {
                                unset($save_array[$i]['subs'][$n]);
                            } # endif exists
                        }
                    } # end subs
                } # end tables
            } # end removes
        }

        # remove fields
        if (is_array($this->_ignore['fields'])) {
            foreach ($this->_ignore['fields'] as $remove) {
                foreach ($save_array as $k => $v) {
                    if (is_array($v['fields']) &&
                        array_key_exists($remove, $v['fields'])
                    ) {
                        unset($save_array[$i]['fields'][$remove]);
                    }
                }
            }
        }

        return $save_array;
    }

    /**
     * @return Model       $this
     * @throws Exception
     */
    public function makeProperties()
    {
        if ($this->getStoredAql()) {
            $this->makeAqlArray();
            $i = 0;
            foreach ($this->getStoredAqlArray() as $table) {
                if ($i == 0) {
                    $this->_primary_table = $table['table'];
                    $this->addProperty($this->_primary_table.'_id');
                }
                $this->tableMakeProperties($table);
                $i++;
            }
        } else {
            $e = sprintf(self::E_INVALID_MODEL, $this->_model_name);
            if (!is_ajax_request()) {
                throw new Exception($e);

                return $this;
            } else {
                exit_json(array(
                    'status' => 'Error',
                    'errors' => array(
                       $e
                    )
                ));
            }
        }

        return $this;
    }

    /**
     * @param string $offset
     */
    public function offsetExists($offset)
    {
        return isset($this->_data[$offset]);
    }

    /**
     * @param string $offset
     */
    public function offsetGet($offset)
    {
        return (isset($this->_data[$offset])) ? $this->_data[$offset] : null;
    }

    /**
     * @param string $offset
     * @param value $value
     */
    public function offsetSet($offset, $value)
    {
        if (is_array($value)) {
            $value = self::toArrayObject($value);
        }
        $this->$offset = $value;
    }

    /**
     * @param string $offset
     */
    public function offsetUnset($offset)
    {
        unset($this->_data[$offset]);
    }

    /**
     * Reloads the current object from DB, resetting cache,
     * and updates all model dependencies as well
     * @param   array   $save_array
     * @return  $this
     */
    public function reload($save_array = array())
    {
        $t = $this->getPrimaryTable();
        $id = $save_array[$t]['id'] ?: $this->_id;
        $this->_id = ($id) ?: $this->getID();

        if ($this->_id) {

            $this->loadDB($this->_id, true, true);
            foreach ($this->getModelDependencies() as $m) {
                Model::get($m, $this->_id, true);
            }

        }

        $this->construct();

        return $this;
    }

    /**
     * Gets a list of models dependent on the current model's primary table
     * excluding the current model
     * Note: models constructed using new Model($id, $aql) will not have a model name.
     * @return array
     */
    public function getModelDependencies()
    {
        $name = $this->_model_name;
        return array_filter(
            static::getAllModelDeps($this->getPrimaryTable()),
            function($model) use($name) {
                return $model != $name;
            }
        );
    }

    /**
     * Makes sure that deps are an array centralizes where they are fetched from
     * @param   string  $primary_table
     * @return  array
     * @global  $model_dependencies
     */
    public static function getAllModelDeps($primary_table = null)
    {
        global $model_dependencies;
        $deps = $model_dependencies ?: array();

        return ($primary_table)
            ? ($deps[$primary_table] ?: array())
            : $deps;
    }

    /**
     * for when using memcache, if there are subobjects, re-fetch them from cache
     * to make sure they are up to date
     * @param  Boolean $use_dbw     use master DB
     * @return Model   $this
     */
    public function reloadSubs($use_dbw = false)
    {
        if (!$this->_refresh_sub_models) {
            return $this;
        }

        $o = $this;

        $load = function($m) use ($o, $use_dbw) {
            if (!Model::isModelClass($m) || !$m->_id) {
                return;
            }
            $m->_force_db = false;
            $m->getModelAql()->makeProperties();
            $m->loadDB($m->_id, $o->_force_db, $use_dbw);
            $m->construct();
        };

        $isPlural = function($type) {
            return ($type === 'plural');
        };

        foreach ($this->_objects as $o => $type) {
            if ($isPlural($type)) {
                foreach ($this->_data[$o] as $obj) {
                    $load($obj);
                }
            } else {
                $load($obj);
            }
        }

        return $this;
    }

    /**
     * disables refresh_sub_models
     */
    public function disableSubReload()
    {
        $this->_refresh_sub_models = false;
    }

    /**
     * @param string   as many as needed, unsets the keys from _properties
     * @return Model   $this
     */
    public function removeProperty()
    {
        $num_args = func_num_args();
        $args = func_get_args();
        for ($i = 0; $i < $num_args; $i++) {
            unset($this->_properties[$args[$i]]);
        }

        return $this;
    }

    /**
     * Inserts a record
     * Usage:
     *      try {
     *          $o = artist::insert([
     *              'name' => 'Pink Floyd'
     *          ]);
     *      } catch (\ValidationException $e) {
     *          // handle validation errors
     *          var_dump($e->getErrors());
     *      }
     * @param   $arr    associative array of values
     * @return  Model   $inserted
     * @throws  \InvalidArgumentException if non associatve or empty array
     * @throws  \LogicException if an identifier is part of the argument
     * @throws  \ValidationException on failure
     */
    public static function insert(array $arr = array())
    {
        if (!$arr || !is_assoc($arr)) {
            throw new InvalidArgumentException('Expects a non empty associative array.');
        }

        $cl = get_called_class();
        $o = new $cl($arr);

        if ($o->getID()) {
            throw new LogicException('Cannot insert when an identifier is set.');
        }

        $o->save();
        if ($o->_errors) {
            static::error($o->_errors);
        }

        return $o;
    }

    /**
     * Updates a Model record, throws exceptions on failure
     * Usage:
     *      try {
     *          $artis = new artist($id);
     *          $artist->update([
     *              'bio' => $biography_text
     *          ]);
     *      } catch (\ValidationException $e) {
     *          vard_dump($e->getErrors());
     *      }
     * @see saveProperties()
     * @param   $arr    associative array of values
     * @throws  \ValidationException
     * @return  Model   $this
     */
    public function update(array $arr = array())
    {
        $this->saveProperties($arr);
        if ($this->_errors) {
            static::error($this->_errors);
        }

        return $this;
    }

    /**
     * Saves given properties on this model object
     * If the save is not a success, errors are appended to $this->_errors
     * @param  array $arr                  associative array of values to save
     * @return array                       response array
     * @throws InvalidArgumentException    if non associative array given
     * @throws BadMethodCallException      if model has no identifier
     */
    public function saveProperties($arr = array())
    {
        if (!$this->hasID()) {
            throw new BadMethodCallException('No identifier in model');
        }

        if (!$arr || !is_assoc($arr)) {
            throw new InvalidArgumentException('Expects a non empty associatve array.');
        }

        $class = get_called_class();
        $t_ide = $this->getPrimaryTable() . '_ide';
        $arr = array_merge($arr, array(
            $t_ide => $this->getIDE(),
            '_token' => $this->getToken()
        ));

        $tmp = new $class($arr);
        $re = $tmp->save();

        if ($re['status'] == 'OK') {
            foreach (array_keys($arr) as $k) {
                $this->$k = $tmp->$k;
            }
        } else {
            $this->addErrors($tmp->_errors);
        }

        return $re;
    }

    /**
     * Stops the transaction and triggers failure if necessary
     * Flags the instance as no longer _in_transaction
     * @param   Boolean     $trigger_fail
     * @param   Boolean     $save           dictates what kind of error response it is
     * @return  array       response array
     */
    final protected function getTransactionResponse($trigger_fail = false, $save = false)
    {
        $this->_in_transaction = false;
        $this->stopTransaction($trigger_fail);

        return ($trigger_fail)
            ? (($save) ? $this->handleSaveFailure() : $this->errorResponse())
            : $this->successResponse();
    }

    /**
     * has hooks that take the save array as an argument
     *     - before_insert, after_insert
     *     - before_update, after_update
     * @param   Boolean     $inner  if this is an inner save
     * @return  array               response array
     */
    public function save($inner = false)
    {
        if ($this->_in_transaction) {
            $this->addInternalError('fatal_error', array(
                'type' => 'recursive_save',
                'message' => 'Cannot call delete/save inside Model::save()'
            ));

            return;
        }

        // do not attempt validation/save if we have no master DB
        if (!$this->getMasterDB()) {
            $this->addInternalError('read_only');
            return $this->errorResponse();
        }

        if ($inner || $this->inTransaction()) {
            $this->_use_token_validation = false;
            $this->_is_inner_save = true;
        }

        // start a transaction for this save
        $this->_in_transaction = true;
        $this->startTransaction();

        // run validation
        $this->tryCallable(array($this, 'runValidation'));

        // if there are db errors, add them to the errors stack
        // these could be as simple as select errors
        // if using aql in validate (not direct sql), the errors will be silent
        if ($this->hasFailedTransaction()) {
            $this->addAQLErrors();
        }

        $aql_arr = $this->getStoredAqlArray();
        if (!$aql_arr) {
            $this->addInternalError('no_model_aql_statement');
        }

        // if there are errors, trigger transaction failure
        if ($this->_errors) {
            return $this->getTransactionResponse(true);
        }

        // store these values because after the save there will be an ID
        $is_insert = $this->isInsert();
        $is_update = $this->isUpdate();

        // [hook_suffix => (bool) perform this hook?]
        $hooks = array(
            'Insert' => $is_insert,
            'Update' => $is_update
        );

        $this->applySaveHook($hooks, 'before');

        $save_array = $this->makeSaveArray($this->_data, $aql_arr);

        // check for save array
        if (!$save_array) {

            $this->getTransactionResponse(true, true);

            if (!$this->_is_inner_save) {
                $this->addInternalError('no_save_array');
            }

            return $this->errorResponse();
        }

        // strip out ignores
        $save_array = $this->removeIgnores($save_array);

        // before_save, if set MUST return a non-empty array
        if ($this->methodExists('before_save')) {
            $save_array = $this->before_save($save_array);
            if (!$save_array) {
                $this->addInternalError('no_save_array', array(
                    'message' => 'Save array was overridden.'
                ));
            }
        }

        // check for errors
        if ($this->_errors) {
            return $this->getTransactionResponse(true, true);
        }

        if ($this->_abort_save) {
            return $this->getTransactionResponse();
        }

        // run actual save
        $save_array = $this->saveArray($save_array);

        if ($this->hasFailedTransaction() || $this->_errors) {
            return $this->getTransactionResponse(true, true);
        }

        // run before reload hook
        if ($this->methodExists('before_reload')) {
            $this->tryCallable(array($this, 'before_reload'));
            if ($this->hasFailedTransaction() || $this->_errors) {
                return $this->getTransactionResponse(true, true);
            }
        }

        // save_array MUST be passed to reload especially if this is an insert
        // we need to have the generated ID from the DB
        $this->reload($save_array);

        // run after insert/update
        $this->applySaveHook($hooks, 'after');

        if ($is_insert) {
            $this->refreshBelongsTo();
        }

        if ($this->hasFailedTransaction() || $this->_errors) {
            return $this->getTransactionResponse(true, true);
        }

        // if we are here, every thing went OK
        $this->_in_transaction = false;
        $this->stopTransaction($this->_rollback_save);

        if ($this->_rollback_save) {
            $this->addInternalError('rollback_triggered');
        }

        return $this->successResponse();
    }

    /**
     * Wraps $fn($arg1, $arg2, ...)  in a try catch block
     * Adds \ValidationException->getErrors() to the _errors stack
     * other Exceptions caught added as fatal_errors
     * Usage:
     *      $model->tryCallable(function() use($model) {
     *          Model::error('something_happened');
     *      });
     *      var_dump($model->_errors); // this will have a \ValidationError that
     * @param   callable    $fn
     * @param   ...         $args to apply
     * @return  $this       Model
     */
    public function tryCallable($fn /*, $args */)
    {
        try {
            $args = array_slice(func_get_args(), 1);
            call_user_func_array($fn, $args);
        } catch (\ValidationException $e) {
            $this->addErrors($e->getErrors());
        } catch (\Exception $e) {
            $this->addInternalError('fatal_error', array(
                'message' => $e->getMessage(),
                'type' => get_class($e)
            ));
        }

        return $this;
    }

    /**
     * Executes method if it exists for each of the key in $settings
     * inside tryCallable() to catch Exceptions during a save()
     * @see     Model::tryCallable()
     * @see     Model::save()
     * @param   array   $settings   [hook_suffix => bool]
     * @param   string  $prefix
     */
    protected function applySaveHook(array $settings, $prefix = '')
    {
        foreach ($settings as $name => $check) {
            $method_name = $prefix . $name;
            if ($check && $this->methodExists($method_name)) {
                $this->tryCallable(array($this, $method_name));
            }
        }
    }

    /**
     * @return array
     */
    protected function handleSaveFailure()
    {
        if ($this->isDev()) {
            $extra = array(
                'model' => $this->_model_name,
                'data' => $this->_data,
                'aql_errors' => aql::$errors
            );
        } else {
            $extra = array();
        }

        $found = false;
        foreach ($this->_errors as $i => $e) {
            if ($e->code == 'model_save_failure') {
                $found = true;
                $e->curr[] = $extra;
                break;
            }
        }

        if (!$found) {
            $this->addInternalError('model_save_failure', $extra);
        }

        return $this->errorResponse();
    }

    /**
     * Internal function triggered before after_insert and after_delete,
     * if belongs_to is defiend it should be in this structure:
     *      [ model_name => [constructor_field] ]
     *
     * IE: if this model is artist_album, which has artist_id
     *      public $_belongs_to = [
     *          'artist' => 'artist_id'
     *      ];
     *      // or
     *      public $_belongs_to = [
     *          'artist' => ['artist_id', 'parent__artist_id']
     *      ]
     *
     * @return Model   $this
     */
    public function refreshBelongsTo()
    {
        if (!$this->_belongs_to || !is_assoc($this->_belongs_to)) {
            return $this;
        }

        foreach ($this->_belongs_to as $model => $fields) {
            foreach (\arrayify($fields) as $f) {
                if ($this->{$f}) {
                    $model::refreshCache($this->{$f});
                }
            }
        }

        return $this;
    }

    /**
     * aql::insert/update on the save array depending on what needs to be done
     * recursive because of sub objects / queries
     * @param   array   $save_array     array to save
     * @param   array   $ids            ids to pass through
     * @return  array                   updated save array
     */
    final private function saveArray($save_array, $ids = array())
    {
        $is_dev = $this->isDev();

        // copy out objects
        $objects = $save_array['__objects__'];
        unset($save_array['__objects__']);

        // helper function
        $addRecordInfo = function($table_block, $is_update = false) {

            $fields = array(
                'update' => array('mod__person_id', 'update__person_id'),
                'insert' => array('insert__person_id')
            );

            $key = $is_update ? 'update' : 'insert';
            $time_field = $key . '_time';

            if (!$table_block['fields'][$time_field]) {
                $table_block['fields'][$time_field] = aql::now();
            }

            if (!defined('PERSON_ID') || !is_numeric(PERSON_ID)) {
                return $table_block;
            }

            $id = PERSON_ID;
            $fields = $fields[$key];
            foreach ($fields as $field) {
                $table_block['fields'][$field] = $table_block['fields'][$field] ?: $id;
            }

            return $table_block;
        };

        foreach ($save_array as $table => $info) {

            // make sure this is an array
            $info['fields'] = arrayify($info['fields']);

            foreach ($ids as $n => $v) {

                if (is_array($this->_ignore['fields']) &&
                    in_array($n, $this->_ignore['fields'])
                ) {
                    // since ids are added to each table in case of foreign keys
                    // abort if they are being ignored in this model
                    continue;
                }

                // add the id to the table block iff there are already fields
                if ($info['fields'] && !$info['fields'][$n]) {
                    $save_array[$table]['fields'][$n] = $v;
                    $info['fields'][$n] = $v;
                }
            }

            if ($info['fields']) {

                $is_update = $info['id'] && is_numeric($info['id']);
                $info = $addRecordInfo($info, $is_update);

                if ($is_update) {

                    aql::update($table, $info['fields'], $info['id'], true);

                } else {

                    $rs = aql::insert($table, $info['fields'], true);
                    $save_array[$table]['id'] = $info['id'] = $rs[0][$table . '_id'];

                }

            }

            $ids[$table . '_id'] = $info['id'];
            if (is_array($info['subs'])) {
                foreach ($info['subs'] as $i => $sub) {
                    $save_array[$table]['subs'][$i] = $this->saveArray($sub, $ids);
                }
            }
        }

        if (is_array($objects)) {

            foreach ($objects as $o) {

                if (!$o['data']) {
                    continue;
                }

                $tmp = Model::get($o['object']);
                $tmp->_data = $o['data'];
                $tmp->loadIDs($ids);

                $pt = $tmp->getPrimaryTable();
                $pt_id = $pt.'_id';
                if (!$tmp->{$pt_id} && $this->$pt_id) {
                    $tmp->$pt_id = $this->$pt_id;
                }

                $tmp->save(true);

                if ($tmp->_errors) {
                    $this->addErrors($tmp->_errors);
                    $this->failTransaction();
                }

            }
        }

        $save_array['objects'] = $objects;

        return $save_array;
    }

    /**
     * Adds the properties of every the aliases in the aqlarray (table block)
     * @param   string  $table
     * @param   mixed   $sub
     */
    public function tableMakeProperties($table, $sub = null)
    {
        if (is_array($table['objects'])) {
            foreach ($table['objects'] as $k => $v) {
                if (!$this->propertyExists($k)) {
                    $this->addProperty($k)->$k = array();
                }
                $this->_objects[$k] = ($v['plural']) ? 'plural' : true;
            }
        }

        if (is_array($table['fields'])) {
            foreach ($table['fields'] as $k => $v) {
                if (preg_match('/[\b_]id$/', $k)) {
                    $this->addProperty($k.'e');
                }
                $this->addProperty($k);
            }
        }

        if (is_array($table['subqueries'])) {
            foreach ($table['subqueries'] as $k => $v) {
                if (!$this->propertyExists($k)) {
                    $this->addProperty($k)->$k = array();
                }
            }
        }

        $this->addProperty($table['table'].'_id');
    }

    /**
     * transforms modelArrayObject to an array recursively
     * @param ModelArrayObject $obj
     * @return array
     */
    public function toArray($obj)
    {
        if (is_object($obj) && get_class($obj) == 'ModelArrayObject') {
            $obj = $obj->getArrayCopy();
        }

        if (is_array($obj)) {
            foreach ($obj as $k => $v) {
                $obj[$k] = self::toArray($v);
            }
        }

        return $obj;
    }

    /**
     * transforms array to arrayobject recursively
     * @param array $arr
     * @return ModelArrayObject
     */
    public function toArrayObject($arr = array())
    {
        $arr = new ModelArrayObject($arr);
        foreach ($arr as $k => $v) {
            $arr[$k] = (is_array($v)) ? self::toArrayObject($v) : $v;
        }

        return $arr;
    }

    /**
     * @return Model       $this
     */
    public function runValidation()
    {
        // run preValidation if the method is defined
        $this->callIfExists('beforeCheckRequiredFields');

        if ($this->_errors && $this->hasErrorStrings()) {
            return $this;
        }

        $is_update = $this->isUpdate();
        $is_insert = $this->isInsert();

        // check if this is a valid token
        if (!$this->isValidToken($this->_token)) {
            $this->_return['token'] = $this->_token;
            $this->addInternalError('invalid_token');

            return $this;
        }

        // check required fields
        $this->checkRequiredFields();

        // exit validation if there are errors and we dont want to continue
        if ($this->_errors && $this->hasErrorStrings()) {
            return $this;
        }

        // check field specific validation
        // if field is set, has validation method, and does not already have errors
        $this->checkValidateFields();

        // exit validation if there are errors
        if ($this->_errors) {
            return $this;
        }

        // execute post validate
        $this->callIfExists('validate');

        return $this;
    }

    /**
     * Checks if given token is valid for this model,
     * If model doesn't use token validation OR this is an insert, always true.
     * @param   string  $token
     * @return  Boolean
     */
    final public function isValidToken($token = null)
    {
        if ($this->isInsert() || !$this->_use_token_validation) {
            return true;
        }

        $model_token = $this->getToken();
        return ($token && $model_token == $token);
    }

    /**
     * Runs validate_ methods on fields
     * @return  $this
     */
    final public function checkValidateFields()
    {
        $fields = $this->getFieldsWithValidateMethods();
        array_walk($fields, array($this, 'runValidationMethod'));

        return $this;
    }

    /**
     * Get an array of fields that have ValidationMethods defined
     * @return  array
     */
    final public function getFieldsWithValidateMethods()
    {
        // using array_values to reset array indices
        return array_values(
            array_filter($this->getProperties(), array($this, 'fieldHasValidation'))
        );
    }

    /**
     * Excecutes a validation method on a field if it is set,
     * and the field does not already have errors
     * @return  $this
     */
    final public function runValidationMethod($property)
    {
        if (!$this->fieldHasErrors($property) && $this->fieldIsSet($property)) {
            $method = $this->getValidationMethodName($property);
            $this->$method($this->$property);
        }

        return $this;
    }

    /**
     * Runs the required field test for each required field
     * @return  $this
     */
    final public function checkRequiredFields()
    {
        return $this->checkFields($this->_required_fields);
    }

    /**
     * Runs the required field test for each given field
     * Skips fields that already have errors
     * Skips fields if the field is not set and this is an update
     * @param   array   $params associative
     *                  { field: display_name }
     * @return  $this
     */
    final public function checkFields(array $fields = array())
    {
        if ($fields && !\is_assoc($fields)) {
            throw new InvalidArgumentException('checkFields param is not associative.');
        }

        // only run requiredField test if the field does not already have errors
        // and if it is being changed (update), always on insert
        foreach ($fields as $field => $name) {

            $ignore = !$this->fieldIsSet($field) && $this->isUpdate();
            if ($this->fieldHasErrors($field) || $ignore)  {
                continue;
            }

            $name = $name ?: $field;
            $this->requiredField($field, $name, $this->{$field});
        }

        return $this;
    }

    /**
     * @return Boolean
     */
    public function hasPossibleErrors()
    {
        return (bool) static::$possible_errors;
    }

    /**
     * This exists for Backwards Compatibility, old errors are not ValidationError objects
     * so we do not know what field they belong to
     * @todo    remove this method when models are ported to use possible_errors
     * @return Boolean
     */
    protected function hasErrorStrings()
    {
        foreach ($this->_errors as $e) {
            if (is_string($e)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Loops through errors to check if the field already has an error set
     * @param  string  $field
     * @return Boolean
     */
    protected function fieldHasErrors($field)
    {
        foreach ($this->_errors as $error) {
            if (is_object($error) &&
                is_array($error->fields) &&
                in_array($field, $error->fields)
            ) {
                return true;
            }
        }

        return false;
    }

    /**
     * Prints data array
     */
    public function printData()
    {
        print_pre($this->_data);
    }

    /**
     * Prints errors array
     */
    public function printErrors()
    {
        print_pre($this->_errors);
    }

    /**
     * @param  string  $p
     * @return Boolean
     */
    public function propertyExists($p)
    {
        return array_key_exists($p, $this->_properties);
    }

    /**
     * @param  array   $arr
     * @return string  JSON
     */
    public static function returnJSON($arr = array())
    {
        return json_encode($arr);
    }

    /**
     * @return array
     */
    public function returnDataArray()
    {
        return $this->_data;
    }

    /**
     * If data is not set/null, add a ValidationError to the stack
     * type is field_is_required
     * @param  string  $field
     * @param  string  $display_name
     * @param  mixed   $val
     */
    public function requiredField($field, $display_name, $val)
    {
        if (!is_null($val) && $val !== '') {
            return;
        }

        $this->addInternalError('field_is_required', array(
            'message' => sprintf(self::E_FIELD_IS_REQUIRED, $display_name),
            'fields' => array($field)
        ));
    }

    /**
     * @param  string  $field_name
     * @return Boolean
     */
    public function fieldIsRequired($field_name)
    {
        return array_key_exists($field_name, $this->_required_fields);
    }

    /**
     * @param  string  $field_name
     * @return Boolean
     */
    public function fieldIsSet($field_name)
    {
        return array_key_exists($field_name, $this->_data);
    }

    /**
     * @param  string  $field_name
     * @return Boolean
     */
    public function fieldHasValidation($field_name)
    {
        return $this->methodExists($this->getValidationMethodName($field_name));
    }

    /**
     * @param   string  $field
     * @return  string
     */
    public function getValidationMethodName($field)
    {
        return self::$validation_prefix . $field;
    }

    /**
     * @return Boolean
     */
    public function isInsert()
    {
        return !$this->{$this->_primary_table . '_id'};
    }

    /**
     * @return Boolean
     */
    public function isUpdate()
    {
        return !$this->isInsert();
    }

    /**
     * @param string $val
     * @deprecated
     */
    public function validEmail($val)
    {
        $val = trim($val);
        if (!filter_var($val, FILTER_VALIDATE_EMAIL)) {
            $this->_errors[] = new ValidationError(
                'invalid_email',
                array(
                    'message' => "{$val} is not a valid email address."
                )
            );
        }
    }

    /**
     * @return Boolean
     */
    public function isStaticCall()
    {
        if (!isset($this) && !self::isModelClass($this)) {
            return true;
        }
        $bt = debug_backtrace();

        return (!is_a($this, $bt[1]['class']));
    }

    /**
     * @param array $sets  associative
     * @return Model       $this
     */
    private function setConfig($sets = array())
    {
        if (!$sets) {
            return $this;
        }

        $re = new ReflectionClass($this);
        $props = $re->getProperties(ReflectionProperty::IS_PROTECTED);
        foreach ($props as $prop) {
            $prop_name = $prop->getName();
            $key = substr($prop_name, 1);
            if (array_key_exists($key, $sets)) {
                $this->{$prop_name} = $sets[$key];
                unset($sets[$key]);
            }
        }

        return $this;
    }

    /**
     * Gets aql::$errors and adds them to the stack
     */
    protected function addAQLErrors()
    {
        foreach (aql::$errors as $e) {
            $this->addInternalError('aql_class_error', array(
                'message' => $e->getMessage(),
                'Exception' => $e
            ));
        }

        aql::$errors = array();
    }

    /**
     * Adds an internal error to the stack
     * @param  string  $error_code
     * @param  array   $params
     * @return Model   $this
     */
    protected function addInternalError($error_code, array $params = array())
    {
        $this->_errors[] = static::getError($error_code, $params, true);
        return $this;
    }

    /**
     * @param   array   $errors
     * @return  $this
     */
    public function addErrors(array $errors = array())
    {
        $this->_errors = array_merge($this->_errors, $errors);
        return $this;
    }

    /**
     * Adds an error to the stack ($this->_errors)
     * @param  string  $error_code
     * @param  array   $params
     * @return Model   $this
     */
    public function addError($error_code, $params = array())
    {
        $this->_errors[] = static::getError($error_code, $params);
        return $this;
    }

    /**
     * Gets a ValidationError object for the given $error_code
     * if it is found in static::$possible_errors || static::$internal_errors
     * @param  string  $code
     * @param  array   $params
     * @param  Boolean $internal
     * @return ValidationError
     * @throws \Exception       if error_code is not found
     */
    public static function getError($code, $params = array(), $internal = false)
    {
        $errors = ($internal) ? self::$internal_errors : static::$possible_errors;
        if (!is_string($code)
            || !array_key_exists($code, $errors)
            || !is_array($errors[$code])
        ) {
            throw new Exception('Invalid error_code.');
        }

        # merge the predefined properties of this error_code with the specified params
        $error_params = array_merge($errors[$code], $params);
        return new ValidationError($code, $error_params);
    }

    /**
     * Stops execution of the method and throws ValidationException with all errors
     * that have been added to the error stack.
     * @param  mixed   $a      Either a string $error_code,
     *                         Error object, or an array of error objects
     * @param  array   $params Optional array for customizing the error output
     * @throws \ValidationException
     */
    public static function error($a, $params = array())
    {
        if (is_array($a)) {
            $errors = $a;
        } elseif (is_string($a)) {
            $error_code = $a;
            $errors = array(static::getError($error_code, $params));
        } elseif (is_a($a, 'ValidationError')) {
            $error = $a;
            $errors = array($error);
        }

        throw new ValidationException($errors);
    }

    /**
     * @return Boolean
     * @global $is_dev
     */
    protected function isDev()
    {
        global $is_dev;
        return $is_dev || \Sky\Api::$is_dev;
    }

}

/**
 * @todo use this for when loadDB() fails to find data
 */
class ModelNotFoundException extends Exception { }
